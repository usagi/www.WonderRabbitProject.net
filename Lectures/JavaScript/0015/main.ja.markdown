--
title:     15. JavaScriptの言語組み込みオブジェクト（RegExp編）
parent:    JavaScript ⇠ Lectures
published: 2012-06-13 21:30
--

<a target="_blank" href="https://github.com/usagi/www.WonderRabbitProject.net/commits/master/Lectures/JavaScript/0014/main.ja.markdown">
<ul class="datetime">
  <li class="published"><time pubdate datetime="$published$">$published$</time>
  <li>change log is here
</ul>
</a>

<nav>

##### 概要

[ECMA-262]に定義される言語組み込みオブジェクトの紹介シリーズは
今回紹介する RegExp （正規表現）オブジェクトで御終いです。

余談ですが、RegExpは"Regular Expression"の略称である事に気が付けば
スペリングなど忘れ難くなるかもしれませんね・ｗ・
JavaScriptのみならず多くの言語で正規表現はRegExpと略記される事も多いので
覚えてしまいましょう。

##### 内容

<nav>

- [15.1 基本的な正規表現のパターン](#基本的な正規表現のパターン)
- [15.2 ECMA-262のRegExpの機能](#ECMA-262のregexpのパターン)
    - [15.2.1 コンストラクト](#コンストラクト)
    - [15.2.2 実行 exec](#実行 exec)
    - [15.2.3 テスト test](#テスト test)
    - [15.2.4 各種プロパティ](#各種プロパティ)

</nav>

## 15.1 基本的な正規表現のパターン

正規表現は文字列の表現を抽象化する事で、特定の文字列ではなく、
特定のパターンと照合する機能です。
先ずは前回軽く登場したStringオブジェクトの`match`や`search`を使い、
代表的なパターンを紹介します。

最も基本的な事項として、正規表現特有の機能に使われない文字は
正規表現のパターン文字列の中では、特定のその文字1文字そのものを表します。

    > a = 'abcDEF123'
    'abcDEF123'
    > a.search('DEF')
    3

Stringオブジェクトの`search`は正規表現のパターンを引数として、
そのパターンが現れる位置を返す関数でした。
この例では'DEF'を構成する文字は、
'D'も'E'も'F'も正規表現のパターンとしては特別な意味を持ちませんから
それぞれの文字を表すパターンとして機能します。
よって、正規表現パターン'DEF'は文字列の'DEF'にマッチします。

続いては`[`と`]`で囲んだパターンを紹介します。

    > a.search('[A-Z][0-9]')
    5

`[`と`]`で囲まれた部分1つにつき1つの文字に対応します。
この例では`[A-Z]`と`[0-9]`で2文字のパターンを表し、
1つめの`[A-Z]`は「'A'以上'Z'以下の任意の文字」、
2つめの`[0-9]`は「'0'以上'9'以下の任意の文字」
にそれぞれヒットします。

注意として、ヒット対象は文字ですから、
以上とか以下とは文字コードの数値を比較しての話となります。

また、`[`と`]`で囲まれたパターンはA以上B以下という範囲指定の他、

    > a.search('[abc][DEF]')
    2

の様に特定の文字の何れかにヒットするパターンも記述でき、
１つのパターンの中で範囲指定と特定の文字の列挙を併用する事もできます。

    > a.search('[a-zABCDEF345]')
    0

そしてもう1つ、`[`と`]`で囲まれたパターンには否定表現があります。

    > a.search('[^a-zA-Z]')
    6

`[`の直後に`^`がある場合は`]`までに含まれない1文字を表します。

更に、正規表現では「直前の文字が何文字分連続して出現するか」を
パターンとして表現できます。

    > a.search('[A-Z]{3}')
    3

`{3}`は直前の1文字分のパターンが3回連続するパターンを意味します。

    > a.search('[A-Z]{2,4}')
    3

`{2,4}`は直前の1文字分のパターンが2回以上4回以下連続するパターンです。

この他に正規表現では、「任意の1文字」を表す`.`: 

    > a.search('...[0-9]{3}')
    3

「任意の出現回数」を表す`*`:

    > a.search('DEF[a-z]*[0-9]{3}')
    3

（※任意の出現回数とは0回以上である点に注意）

「1回以上の出現回数」を表す`+`:

    > a.search('[a-z]+[A-Z]+[0-9]+')
    0

「0回または1回の出現回数」を表す`?`:

    > a.search('DEF?[0-9]{3}')
    3

「パターンのグループ」を表す`(`と`)`の囲み:

    > a.search('([a-zA-Z0-9]{3}){3}')
    0

（※上記は「`[a-zA-Z0-9]`が`{3}`回」というパターンをグループとして`{3}`回というパターン。また、`()`グループは`match`を使用した際には事後にグループ単位毎にヒット内容を参照もできる。）

「OR条件」を表す`|`: 

    > a.search('(abc|DEF){2}')
    0

（※上記は「`abc`または`DEF`」というパターンを`{2}`回というパターン。）

「評価対象の先頭」を意味する`^`:

    > a.search('^abc');
    0

（※`^`はパターンの文脈により複数の意味で使われる事に注意。）

「評価対象の末尾」を意味する`$`:

    > a.search('123$');
    6

「正規表現の特別な意味を持つ文字の意味を無効化する`\`」:

    > a.search('DEF\[012]{3}')
    -1

と、少なくともこのくらいの応用までは
リファレンス無しで使える様になっておくと便利でしょう・ｗ・ｂ

## 15.2 ECMA-262のRegExpの機能

Stringオブジェクトに対して`search`または`match`する他に、
RegExpオブジェクトを予め用意しておき、
それに対してStringオブジェクトを投げる使い方を出来ます。

### 15.2.1 コンストラクト

    > re = new RegExp('[A-Z]+')
    /[A-Z]+/

正規表現パターンを表す文字列を引数として、
RegExpオブジェクトを生成します。

<div class="note">
Note: 正規表現のパターンは一般に`/pattern/`の様に
パターンの前後を同じ文字（特に`/`）で囲んで、
それが正規表現である事を意味する事が多い。
実は[ECMA-262]でもこのパターンを用いて正規表現を使用できる。

    > /[A-Z]+/
    /[A-Z]+/

知っていると簡潔な他、正規表現の動作に関するフラグも扱える様になる。

    > '-123abc'.search(/[A-Z]/i)
    4

例えば`i`を正規表現パターンを囲む`/`の後ろに付けると
大文字と小文字を区別しなくなる。

他にも`m`で複数行モードのフラグを使える。
複数行モードが有効でない場合は1行ごとに分割してマッチングが行われるが、
複数行モードでは評価対象全体を一度に判定する。
</div>

### 15.2.2 実行 exec

RegExpオブジェクトに対して
Stringオブジェクトを投げつけてマッチング結果を得ます。

    > re.exec('abcDEF012')
    [ 'DEF',
      index: 3,
      input: 'abcDEF012' ]

この結果は、以下の様にStringオブジェクトにRegExpオブジェクトを投げつけても
得られる結果は同じです。必要に応じて使い分けましょう。

    > 'abcDEF012'.match('[A-Z]')

### 15.2.3 テスト test

RegExpオブジェクトに対してStringオブジェクトを投げつけて
真偽値のマッチング結果を得ます。

    > re.test('abcDEF012')
    true

パターンにヒットするかどうかだけを知りたい場合に有用です。

    > -1 !== 'abcDEF012'.search('[A-Z]+')

上記の様にStringオブジェクトの`search`結果を
`-1`と`!==`しても同様の結果は得られます。

### 15.2.4 各種プロパティ

`source`プロパティでパターンを取得できます。

    > re.source
    '[A-Z]+'

（※設定はできない）

`global`プロパティで大域変数か確認できます。

    > re.global
    false

`ignoreCase`プロパティで大文字と小文字を区別しないか確認できます。

    > re.ignoreCase
    false

`multiline`プロパティで複数行を一度に評価するかを確認できます。

    > re.multiline
    false

`lastIndex`プロパティで最後にヒットした位置を取得できます。

    > re.lastIndex
    0

正規表現を使いこなして面倒なテキスト処理を簡単に熟せると
色々と楽が出来て効率良くなりますよ・ｗ・ｂ

<div class="note">
Note: と、[ECMA-262]では正規表現しか文字列のパースに用意された
言語組み込みの機能は無いので正規表現のみを語ったが、
世の中では「パーサーコンビネーター」が流行りつつある。
複雑になるほど正規表現はパターンのメンテナンス性が著しく悪くなるが、
パーサーコンビネーターでは保守性を保ち易く、読み書きし易い。
文字列のパースに興味があれば調べて措いて損は無い・ｗ・ｂ
</div>

[prev]: ../0014/
[next]: ../0016/

[gist]:   http://gist.github.com/
[ideone]: http://www.ideone.com/

[ECMA-262]: http://www.ecma-international.org/publications/standards/Ecma-262.htm

