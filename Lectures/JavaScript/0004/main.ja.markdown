--
title:     4. GitとGitHub（後編）→ソシテ
parent:    JavaScript ⇠ Lectures
published: 2012-04-03 01:00
modified:  2012-04-03 08:00
--

<a target="_blank" href="https://github.com/usagi/www.WonderRabbitProject.net/commits/master/Lectures/JavaScript/0004/main.ja.markdown">
<ul class="datetime">
  <li class="published"><time pubdate datetime="$published$">$published$</time>
  <li class="modified"><time datetime="$modified$">$modified$<time/>
</ul>
</a>

<nav>

##### 概要

前回に引き続き、今回はGitHub（とGit）を使って
ソーシャル開発できるようになりましょう。

→ソシテ、いよいよ次回からはJavaScriptで実際に
何かしらのプロジェクトに取り組みながら本格的に
JavaScriptの学習を進めて行きます。

##### 内容

* [4.1.Gitの仕組みについてもう少し詳しく](#gitの仕組みについてもう少し詳しく)
* [4.2.お隣さんとソーシャル開発１（Fork/Pull Request）](#お隣さんとソーシャル開発Fork/Pull Request)
* [4.3.お隣さんとソーシャル開発２（Collaborator）](#お隣さんとソーシャル開発collaborator)
* [4.4.githubのプロジェクト管理機能](#githubのプロジェクト管理機能)
* [4.A.付録](#a.付録)
    * [4.A.1.ここらでちょっとイケてるjavascriptのプロダクトやライブラリーを紹介しておこうかｗ](#a.1.ここらでちょっとイケてるJavaScriptのプロダクトやライブラリーを紹介しておこうか・ｗ・)
    * [4.A.2.「何かしらのプロジェクト」](#a.2.何かしらのプロジェクト)

</nav>

## 4.1.Gitの仕組みについてもう少し詳しく

さて、前回はとりあえずGitというモダンなソフトウェア開発には必須の
バージョン管理システムの１つを、
またそれを活用したオンラインサービスであるGitHubを使う準備をしましたね。
しかし、『実際のところGitとはどんなものなのか、
「分散型」ってなんとなくわかるようなわからないような』
そんな状態だと思います。

そこで、以下で一応程度にもう少しだけ詳しくGitがなんであるかずばっと箇条書きで説明して措きます。

### バージョン管理システムとは？

- リポジトリの中身の変化単位をバージョンとしてその変化内容を記録する仕組み
    - 「リポジトリ」＝「ディレクトリ＋VCSのメタ情報（＝変化を記録する為のファイル群）」と思って措いても構わない
- 略称はVCS（Version Control System）
- Git以外の代表例はSubversion（＝SVN）、Mercurial（＝hg）
    - MicrosoftとかAdobeも独自システムを作ってたりするけどそこらへんはばっさり紹介しない

### Gitはどうやって単なるディレクトリをリポジトリとして管理しているの？

- `git init`したディレクトリには`.git`という隠しディレクトリが作られて、そこにリポジトリとして必要なメタ情報のファイルとか設定とかが入ってる
    - 設定とか実は単なるテキストファイルなので `vim .git/config`とか開いて確認したり編集したりもできる
    - できるけど、普通は`git remote add url`とか`git config origin.remote.url`とかコマンドでやります

#### 実際にちょっと管理情報を確認して見ようか？

前回作成したローカルのリポジトリで次のコマンドを試してみよう

    $ git show

<div class="node">
Note: ちなみにまだコミットしていない変更を加えられたファイルが
リポジトリにある場合は`git status`とすると確認できたりします。
</div>

前回コミット（つまりリポジトリの状態を記録！）した時の内容が表示されましたね？では次のコマンドはどうでしょう？

    $ gitk

さて、このコマンドの結果は少々驚いたかもしれません。
環境により表示の違いはありますが、次の様なGUIでなにやら変更の履歴などを確認できましたね？

![figure.4.1-1](images/gitk.png)

ちなみにこの図はこのウェブサイトのソースを管理するリポジトリでこの記事を書きながら`gitk`としたものです。
`gitk`のメニューの`ファイル`には`git-guiの起動`がありますから、
Git GUIをここから起動してGUIでコミット作業を行う事も簡単です。

![figure.4.1-2](images/git-gui.png)

ちなみにちなみにこの"Git GUI"は"Git Bash"の中で、

    $ git gui

とかして直接起動する事もできます。
ついでを言うと、この`gitk`や`git gui`ならば、
Windowsの人も文字化け無く日本語を読み書きできちゃうみたいです。

もし、Windowsの人で、前回の付録で紹介した"TortoiseGit"はどうも馴染まないなーと思う場合は、
とりあえずはGit標準で使える`gitk`と`git gui`を使ってみるでも良いかもしれませんね。

### ところで、そもそもGitというものについてもう少し詳しく…

- ＠ＩＴというのがあってだな
    - [分散バージョン管理Git/Mercurial/Bazaar徹底比較](http://www.atmarkit.co.jp/fjava/rensai4/devtool03/devtool03_1.html)

### Gitをこれから使う上でやがて登場するコマンドたち

さて、そういうわけで講座の本題ではない事でもあるので、
興味があれば先の＠ＩＴの記事（２００９年なのでちと古い点には留意すること）を見てもらう事にして、
本項では前回使った

    git init
    git config <hogehoge>
    git remote add <hogehoge>
    git add .
    git commit -m "<fugafuga>"
    git push

これらに加えて、今日使うコマンドの説明をしておきましょう・ｗ・ｂ

    git clone <poyopoyo>
    git pull

#### git clone `<poyopoyo>`

`git clone <poyopoyo>`は、「どこか」にあるリポジトリを「ここらへん」にクローンする為のコマンドです。
「どこか」は`http://`で始まるURLでもいいし、
`../nekoneko`とすれば現在作業中の１つ上の"nekoneko"というディレクトリからにもできますし、
`git@github.com:alice/my-project-1`
（実はこれはメールアドレスなんかではなくて、SSHと呼ばれるプロトコルのURLです）の様にすればSSHという接続方式で
GitHubのディレクトリからクローンする事もできます。

では、どんな「どこか」ならば指定できるのかと言うと、実はとても話は簡単。
Gitのリポジトリを表すURLなら何でも構わないと思って良いでしょう。
思い出してみて下さい、Gitのリポジトリは所詮は".git"というメタ情報を収めたディレクトリを内部に追加しただけの
ただのディレクトリだった事を。そして、Gitのリポジトリはどこの誰が親で子でといった事は無く、
単細胞生物の分裂よろしくそっくりそのままクローニングして、なおかつ独立できてしまうものだという事も。

そんなわけで、クローン元がGitHubのSSH接続した先であっても、
あるいはローカルのディレクトリであっても、まあ何でも構わないのです。
（もちろん、gitが未対応のプロトコルは使えませんけど、理屈としてはそういう事です）

さて、`clone`に成功すると、作業中のディレクトリにクローン元のリポジトリの名前のディレクトリが作られ、
それはもう独立した１つの、新たにクローニングされたリポジトリとして使用できるものです。
この後の実習で実際に使ってみて、体験としてこの感覚を覚えてしまいましょう！

#### git pull

今回はもう１つ

    git pull

このコマンドを知る必要もあります。
[前回][prev]の付録でも紹介してあるのですが、
このコマンドはあるリポジトリが設定で"remote"に指定されたリポジトリから
更新情報を取得する為のコマンドです。つまり`push`とは逆ですね。
`push`は"remote"に指定されたリポジトリへコマンドを打ったところにあるリポジトリから
更新情報を送り付ける為のコマンドでしたから。

これも続く実習で実際に使ってどんなものなのか覚えてしまいましょう！

ここまでに紹介したコマンドだけでも、最低限ではありますが、
Gitを使いチーム開発する為に知らなければ始められないコマンドは全て登場しました。
早速、練習としてお隣さんとソーシャル開発してみましょう！

<div class="note">
Note: これだけ？他には？？

他にもGitを使い熟せる様になって来ると、
`reset`/`revert`/`branch`/`checkout`/`tag`/`stash`/`rebase`
などのコマンドを使う時が来るかもしれません。

- 参考: SourceForge.jp (2009)
    - [Gitを使いこなすための20のコマンド](http://sourceforge.jp/magazine/09/03/16/0831212)

とはいえ、しつこい様ですが日常の基本は`add`/`commit`、そして`push`です。
あまり最初から色々と覚えようとせず、
今の自分に必要最小限なものから順に、確実に覚えて使える様になって行くと良いでしょう・ｗ・ｂ
</div>

## 4.2.お隣さんとソーシャル開発１（Fork/Pull Request）

とりあえず、此処から先は一人じゃできないので、
ペアプロ（＝ペアプログラミング）してくれる誰かを最低でも一人確保しよう。
予め言ってあるから、グループはもうだいたい作れる状態になっているかな？
もし面倒な様なら練習用のペアを先生が勝手に座っている位置が近い人同士とかで指定しちゃいます。

と、まあさておき、この節で重要なことは３つ。

1. GitHubのリポジトリも１つ１つの独立したGitリポジトリ
1. `clone`の自由とGitHubの`Fork`
1. `push`の不自由と代わりに`Pull Request`

### 4.2.1.GitHubのリポジトリも１つ１つの独立したGitリポジトリ

AliceとBobが居たとしよう。
この二人に面識はありませんが、二人ともGitHubを使っています。

先ず、Aliceが自分の計算機に（ローカル）リポジトリＡを作り、
またGitHubの自分のアカウントにも（リモート）リポジトリＢを作成し、
ＡからＢに`push`して開発していたとしよう。

次に、BobがAliceのリポジトリＢをGitHubで見付け、
コードに簡単に直せそうなバグを見付けたけれど、
Aliceはまだそれに気付いて居なさそうだったとしよう。

BobはリポジトリＢからリポジトリＣをGitHubの内部での
`git clone B`の表現である`Fork`を行い、
GitHubの自分（Bob）のアカウントにリポジトリのクローンを作成する。

そしてBobは自分の計算機に自分のGitHubアカウントのリポジトリＣを
クローンし、リポジトリＤを作成した。

つまりこういう事だ。たまにはこの資料でも絵を描こう。

![figure.4.2.1.-1](images/github-social-1.png)

この例ではこの後、BobはリポジトリＤでバグの修正を行いコミットし、
リポジトリＤからリポジトリＣへ`push`し…。

さて、BobはＤからＣへと`push`するのは簡単だ。
なぜなら自分のリポジトリだから勿論書き込み権限を持っている。

しかし、BobはAliceのリポジトリＡに直接…書き込めたらキモいですね？
ではリポジトリＢなら書き込めても気持ち悪く無いでしょうか？
いいえ、それもあまり気分の良い事ではありませんね、
少なくともリポジトリＢの所有者であるAliceにとっては。

ともかく、Gitのリポジトリと言うのは基本的にはそれぞれに独立しているのです。
お互いの情報を共有する為にはそれなりの何かが必要です。
以降ではその１つ目の方法としてGitHubの`Fork`と`Pull Request`について紹介します。

実際に皆さんにもグループ内でお互いに試して見ましょう！

### 4.2.2.`clone`の自由とGitHubの`Fork`

誰でも見えるところにあるリポジトリ（例えばAliceのリポジトリＢ）を`clone`する事ができます。
これは本当にもう、好き勝手に`clone`して構いません。
但し見えないところにあるリポジトリは`clone`できませんけど。

GitHubの「中」でもリポジトリを`clone`する事ができます。
つまり、GitHubのどこか誰かのリポジトリを、
GitHubの自分のアカウントに`clone`して来る事ができて、この機能をGitHubでは`Fork`と呼びます。

<div class="note">
Note: `Fork`は計算機ではしばしば目にするテクニカルタームです。
例えば、「プロセスのFork」という使い方もしますし、
「プロジェクトＡからForkしたＢ」の様に今回のケースにぴったりな言い回しなど。
基となる何かから複製が枝分かれする事を`Fork`と言います。基の何かが半分に分裂じゃないですよ？
（但し、プロジェクトの`Fork`の場合、ソースは基のままでも開発者が分裂してたりはよくありますけれど）
</div>

なお、`clone`すると、手作業で`git init`から作ったリポジトリの時と違って、
`push`とか`pull`する為の"remote"の情報が`remote add`しなくても`clone`するだけで
自動的に設定されてくれます。

つまり、BobはＣからＤを`clone`して作れば、
修正をコミットした後すぐに単に`push`するだけでＤの変更をＣへ適用できます。

### 4.2.3.`push`の不自由と代わりに`Pull Request`

さて、自由な`clone`に対して、`push`は不自由です。
誰でも自由に`push`出来たのでは、
リポジトリを作成した人が意図しない変更を勝手に知らぬ間にされてしまいますからね・ｗ・；

そこで、Bobは今回の様にAliceとは面識もありませんし、
GitHubに自分のリポジトリＣを作ってそこに作業を適用しました。

何故かと言うと、GitHubには`Pull Request`と言う機能があります。
つまり、誰か別のアカウントの人（ここではAlice）に、
「君のリポジトリＢにバグを見つけて、簡単に直せそうだったから修正してＣに置いてあるよ！
是非ＣからＢに`pull`してこの修正をＢにも取り入れてよ！」
と、リクエストできる機能がある訳です。

この機能のお陰で、AliceとBobはお互いに興味の無いどうでも良い世間話やお天気の話、
それから本題の前に相手の事を褒めてあげたりして、それで漸くバグの話に進む電子メールや
チャットの遣り取り無しに、さっくりとAliceはBobがバグを直してくれたことを知れ、
その修正内容もリポジトリＣの変更から簡単にチェックでき、
それを自分のＢにも取り入れ様かどうしようか判断し、
すぐにでもこのソフトウェア開発のプロセスに必要な行動
（AliceがＣからＢへとpullし、Bobがバグ修正してくれた変更を取り込む）を取れるのです！

AliceがBobの変更をGitHubで楽に取り込める為には、
当然BobはAliceが見ることのできるリポジトリＣを持っていなければなりませんから、
先の様なＢからＣを経由してＤで修正してＣを更新して…というプロセスになっていたのです。

### 4.2.4.実際にやってみましょう！

と、まあ、実際にやってみたらそんなに難しい事ではありません。

1. グループ内でお互いにアカウントの「増える！うさぎペアー問題」のリポジトリURLを教えあいましょう
1. 相手のリポジトリを`Fork`して自分のアカウントにクローンを作りましょう
1. 自分のアカウントに`Fork`でクローンしたリポジトリを、`git clone`で自分の計算機にクローンしましょう
1. 計算期間を１年→２年に変更して`add`/`commit`/`push`しましょう
1. GitHubの自分のアカウントのリポジトリから`Pull Request`してみましょう
1. さて、相手も同じ事をしてくれていれば自分のところにも相手からの`Pull Request`が届いているはずです。たぶんGitHubで自動的にmergeできる変更で、すんなりと自分のリポジトリに相手のリポジトリから`pull`して変更を取り込めるでしょう
1. 変更を取り込んだはずの自分のGitHubのリポジトリから自分の計算機の自分のプロジェクトのリポジトリで`pull`をして自分の計算機の自分のリポジトリも更新しましょう。そしてソースが更新された事を確認したなら実行してみましょう

これを、慣れるまで、何度かお互いにやってみましょう。
修正する内容は、例えば１０年先まで計算する様にするだとか、READMEの中身を書くだとか、まあ何でも良いでしょう。

ともあれ、GitHubではこうして見ず知らずの人同士でもソーシャルに連携して開発する事ができるわけです・ｗ・ｂ

## 4.3.お隣さんとソーシャル開発２（Collaborator）

さて、先の修正でAliceとBobはお互いにGitHubでのソフトウェア開発を通じ信頼し合う仲になりました。
二人ともプログラミングに恋してるだけなので色々詮索する必要はありませんし、爆発を祈る必要もありません。

と、AliceがBobをリポジトリＢの共同開発者として信用できるのならば、
GitHubの`Collaborator`という設定を行うとより簡単で円滑に恋の開発スパイラルを進められるようになります。

![figure.4.3.-1](images/github-collaborator-1.png)

↑Aliceはこんな感じでプロジェクトＢのページを表示して、それから`Admin`を開く。

![figure.4.3.-2](images/github-collaborator-2.png)

↑そして左側のメニューの`Collaborators`を開いて
bob（そのリポジトリの共同開発者にするBobのGitHubアカウント名）を`Add`で加える。

すると以降はBobもAliceと同様このリポジトリＢへ直接`push`できるようになる。

Bobはこの後、リポジトリＢから直接自分の計算機用に`clone`してリポジトリＥを作成し、
変更を加えて`commit`したなら`push`するだけでよくなった。
Aliceもリクエストを処理するとかそういった事は無しに、Bobの`push`をリポジトリＢに受けられる。共同開発が楽にできるね！

### 実際にやってみましょう・ｗ・

グループ内で誰か一人が新たにGitHubにリポジトリを新規作成し、
ローカルでも新規に作成した空っぽのリポジトリに
"README"だけでもとりあえず作って`git remote add origin <wanwan>`して`git push -u origin master`しましょう。

<div class="note">
Note: ちなみに、`git push -u oring master`は、
`-u`が「次回からの`push`のデフォルトとして今回の設定を保持する」というオプションで、
`origin`は先に設定した`<wanwan>`に置き換わります。
"remote"については`origin`という別名を`<wanwan>`に付けて保存するのが`git remote add origin <wanwan>`の意味です。
最後の`master`については…ブランチ機能を紹介する時にまた説明しましょう・ｘ・
</div>

さて、GitHubのリポジトリにも無事にREADMEが入りましたか？
そうしたなら、今度はさっそく`Admin`→`Collaborators`からグループになっている人の
GitHubアカウント名を登録してみましょう。

コラボレーターへの登録が済んだなら、コラボレーターになった人はそのリポジトリから
直接`git clone <sono-repository-url>`してローカルの自分の計算機にリポジトリをコピーし、
READMEに何か編集をしてコミットして`push`して見ましょう。

誰かが`push`した更新を自分のローカルのリポジトリにも適用するには`git pull`を使います。
大丈夫ですか？これからコラボ開発できそうですか？？

慣れるまで、グループ内でお互いにリポジトリを作る側を担当したり、
何度か変更を`push`したりしてみるなどしましょう。

おおっと？何やらトラブルが起きましたか？
もしかしたら共同開発者同士の編集内容が重複する部分があったのかもしれません。
上手く両方の変更を取り込んだイケてる修正の修正版を用意してから`push`してみましょう。

こんな感じで編集の「競合」を解決できます:

    $ git push
    To <puyopuyo>
    ! [rejected]        master -> master (non-fast-forward)
    error: failed to push some refs to '<puyopuyo>'
    To prevent you from losing history, non-fast-forward updates were rejected
    Merge the remote changes (e.g. 'git pull') before pushing again.  See the
    'Note about fast-forwards' section of 'git push --help' for details.

大事なのは`[rejected]`という部分。このエラーを読むと、
「pushする前に`pull`してうちトコの最新状態に対しての変更を適用した上で、
おたくさんの変更もしてもう一度`push`してやー」
とかまあそういう意味だと思って下さい。

ここで、`git pull`を試します。この時、もしも変更内容が自動的に両方とも取り入れられる場合
（自分が編集したのはファイルＡの３行目、
その間に誰かが編集してpushしていたものはファイルＡの８行目、みたいな場合）は、
`git pull`だけで事が解決しますので、続けて改めて`git push`し直せば上手く行きます。（たぶん）

しかし、現実にはそうでない場合ももしかしたら起こります。

    $ git pull
    remote: Counting objects: 5, done.
    remote: Total 3 (delta 0), reused 0 (delta 0)
    Unpacking objects: 100% (3/3), done.
    From <puyopuyo>
       d1de501..a0ded40  master     -> origin/master
    Auto-merging test-file.txt
    CONFLICT (content): Merge conflict in test-file.txt
    Automatic merge failed; fix conflicts and then commit the result.

`Automatic merge failed`、アイヤー・ｘ・； こうなった時には仕方がないので手作業で
編集の衝突を修正します。手作業修正する為の元を次の様にして手元に用意します:

    $ git pull --commit
    U       test-file.txt
    Pull is not possible because you have unmerged files.
    Please, fix them up in the work tree, and then use 'git add/rm <file>'
    as appropriate to mark resolution, or use 'git commit -a'.

さて、競合している"test-file.txt"を開いてみましょう。すると、

    <<<<<<< HEAD
    （自分の編集した内容）
    =======
    （remoteの編集されてた内容）
    >>>>>>> a0ded40189334b786059588cc0711e95f3b81c3c

とか競合した部分にマークが付いた状態で両方の変更が仮に含まれた状態になっています。
Windowsの人はたぶんそのソースを手作業で最終的にどうするか編集して、
`git add test-file.txt`して`git push`するのが手っ取り早いと思います。

<div class="note">
Note: Windowsユーザーにデフォルトではお勧めしないのですが、
そうではない玄人WindowsユーザーやそもそもWindowsじゃなくてCUI慣れしてるとか
mergetoolをきちんと使い易いものに設定しているという場合は
`git mergetool -y test-file.txt`
とかすると競合をマージツールで編集して解消できたりもします。
</div>

それから、

    $ git checkout --ours test-file.txt
    $ git add test-file.txt
    $ git commit -m "fix conflict"
    $ git push

こんな風に編集内容に衝突が起きた場合にその衝突を解決する作業をマージと言います。
もし上手くできない時には先生を呼んでみて下さい。

<div class="note">
Note: gitのコマンドの`merge`は先のNoteでもちらりと触れたブランチに関連したものです。
ソフトウェア開発の用語一般としてのマージとGitのコマンドとして`merge`は広義とか狭義とか
そういう感じで意味がちょっと違います。
このコマンドについてもまた、ブランチというものについて説明する時にでも。
</div>

## 4.4.githubのプロジェクト管理機能

実は、今回のJavaScript講座でみんなにGitHubを使って貰う理由は幾つかあったんだけど、
この機能も理由の１つになっています。

![figure.4.4.-1](images/github-issue-1.png)

GitHubのリポジトリを開いた状態だと、
メニューに`Issues`（＝課題たち）と言うのが見える。早速開いてみよう。

この手のものを初めてみる学生も多いかもしれない。
すると、やや複雑そうな印象を受けるかもしれないけれど実は簡単。
このGitHubの`Issues`機能の中身は実は１つ。

ずばり言うと「"Issue"のチケットベースの課題解決支援システムを使用できる」と言うだけなのです。

### チケットベースの課題解決システム

GitHubの`Issues`はとてもシンプルな部類なので、
初めてこの手のシステムを使うのにも適しています。
GitHubを例に「チケットベースの課題解決システム」
の中身を紹介すると次の様な階層構造になっています。

- Milestone（＝小目標）の編集（追加やIssueの割り当て）
    - **Issue（＝課題）チケットの編集（追加や完了）**
        - Issueへのラベリング（ブログに付ける「タグ」みたいなもの）

Issueと言うのが一番小さな単位で、
このリポジトリで開発を進めているプロジェクトの
バグ報告や実装予定の内容、或いは調査や勉強が必要ならそれを書き記しても良いし、
とにかくそのプロジェクトの為にしなくちゃならない事を"Post-it®!"する為の
ミニ掲示板みたいなものだと思うと、まさにその通りです。

<div class="note">
Note: 一般にこの様なシステムでは
プロジェクトの為のPost-it®的なそれを「チケット」と言い、
新しいバグ報告や課題のチケットを発行し、
開発者がそれに基づいて実際の開発行動などを行う様になっています。
</div>

そして、GitHubのシステムではIssueだけではまとまりが無いので
Milestoneという課題をまとめる小目標の為の単位も設けて、
IssueたちをこのMilestoneの中に放り込める様になっています。

それから、Issueたちにはそれぞれに例えば「バグ」だとかの
「ラベル」を付ける機能もあります。これにより、
沢山のIssueが登録された状態でも「バグ」についての報告をチェックしたい時には、
このラベリングから絞り込んだり、或いはIssueを閲覧した人が、
そのIssueは「バグ」である事が一目で分かる仕組みになっています。

また、IssueとMilestoneにはGitHubでそのリポジトリにcommit可能な開発者（＝コミッターと言います）を
そのチケットの担当者として割り当てたり、`Due Date`（＝納期目標）を設定したり、
開発用のカレンダー表示（＝「ガントチャート」と言います）で表示できたり、
単純なチケットシステムとしてプロジェクト管理に必要最小限の機能をしっかりと使える様になっています。

実際に、先程コラボレーターを設定した練習用のリポジトリで、
Issuesを開いて`New Issue`を開いて新しいチケットを発行したり、
それにラベルを付けたりコメントしたり、担当者を充てたり、納期目標を設定したり、
Milestoneを作ってチケットに設定してみたり（例えば「version 1.0 リリース！」とか）、
実際に今日からプロジェクトを進める上で便利で大切な開発支援ツールの１つとして使えるように
これも練習して措きましょう！

## 4.A.付録

## 4.A.1.ここらでちょっとイケてるjavascriptのプロダクトやライブラリーを紹介しておこうか・ｗ・

JavaScriptを使えれば今すぐにでも使えるイケてるライブラリーを幾つか紹介しましょう。
勿論、これらも必要ならばこれから取り組むプロジェクトで使用しても構いません。

こうしたリソースを上手く活用できるよう、
これからしっかりとJavaScriptを学んで下さい・ｗ・ｂ

### Three.js - WebGL and Canvas Library

- [Three.js](https://github.com/mrdoob/three.js/)

HTML5のCanvasやWebGLを使い3Dレンダリングを行う為のJavaScriptライブラリー。
なにはともあれ、現状のJavaScriptとウェブブラウザーで既にどのような事までできるのか、
プロジェクトサイトのリンクなどから辿り、驚くと良い。

但し、まとも動かすにはそれなりにふつう程度のGPUを搭載した計算機が必要である。

### enchant.js - Game Engine

- [enchant.js](http://enchantjs.com/ja/)

JavaScriptとHTML5を使ったゲームエンジン。
日本語の情報も豊富でチュートリアルやサンプルも充実しているから非常に扱い易いと思われる。

### Pot.js - Deffered Library

- [Pot.js](http://polygonplanet.github.com/Pot.js/)

JavaScriptの欠点であるシングルスレッドに起因する高負荷処理時の著しいユーザビリティ低下などを
処理の塊を分解して徐々に実行しつつ、その他の処理もこなす様な挙動へと、
すなわちDeffered化を実現するライブラリー。上手く使う事でUXの向上に役立つ。

### jQuery - DOM Effect Library

- [jQuery](http://jquery.com/)
-- [jQuery UI](http://jqueryui.com/)

恐らくJavaScriptの最も有名なライブラリ。
DOM操作のプログラマビリティを向上させ、
ブラウザーのJavaScriptによるDOMの操作、CSSの操作で
リッチなユーザーインターフェースを構築するのに役立つ。

### YUI - UI Library

- [YUI](http://codecanyon.net/item/jquery-lightbox-evolution/115655)

Yahooが作ってるJavaScriptライブラリ。ユーザーインターフェースのUX向上なんかを実現するのに役立つ。

## 4.A.2.「何かしらのプロジェクト」

（ToDo: この時の素案は後ほど公開予定）

[prev]: ../0003/
[next]: ../0005/

[gist]:   http://gist.github.com/
[ideone]: http://www.ideone.com/

