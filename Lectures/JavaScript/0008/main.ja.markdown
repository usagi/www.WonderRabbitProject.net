--
title:     8. JavaScriptオブジェクト指向プログラミング
parent:    JavaScript ⇠ Lectures
published: 2012-04-12 00:00
--

<a target="_blank" href="https://github.com/usagi/www.WonderRabbitProject.net/commits/master/Lectures/JavaScript/0006/main.ja.markdown">
<ul class="datetime">
  <li class="published"><time pubdate datetime="$published$">$published$</time>
  <li>change log is here
</ul>
</a>

<nav>

##### 概要

今回はJavaScriptに於けるオブジェクト指向プログラミングについて講義します。

##### 内容

* [8.1.JavaScriptのオブジェクト指向とハッシュオブジェクト](#javascriptのオブジェクト指向とハッシュオブジェクト)
* [8.2.this式](#this式)
* [8.3.new演算子とdelete演算子](#new演算子とdelete演算子)
    * [8.3.1.new 演算子](#new演算子)
    * [8.3.2.delete 演算子](#delete演算子)
* [8.4.プロトタイプ](#プロトタイプ)
    * [8.4.1.プロトタイプとは何か？](#プロトタイプとは何か)
    * [8.4.2.プロトタイプ継承とコンストラクターでのthisの使い分け](プロトタイプ継承とコンストラクターでのthisの使い分け)
    * [8.4.3.instanceof 演算子](#instanceof演算子)
* [8.5.コメント](#コメント)
* [8.A.付録](#a.付録)
* [8.A.1.オブジェクト指向JavaScriptプログラムサンプル](#a.1.オブジェクト指向javascriptプログラムサンプル)

</nav>

## 8.1.JavaScriptのオブジェクト指向とハッシュオブジェクト

さて、前回もちらりほらりとハッシュオブジェクトを使って
オブジェクト指向っぽい雰囲気のあるコードが登場していましたね。

例えばFizzBuzzを解くサンプルプログラム: 

- [gist: 2356610](https://gist.github.com/2356610/823cabfada52fad360a0b15ad4f0f3c91c42ad3e)

このコードではJavaScriptのハッシュオブジェクト型により、
JavaやC++で言うところのクラスみたいな事をやっていました。
この様なハッシュオブジェクトの使用を基にして、
JavaScriptではオブジェクト指向パラダイムのプログラミングを行います。

ハッシュオブジェクトは`key:value`のペアーの集合です。

    {
      aaa: 123,
      bbb: 'hoge'
      ccc: function() { },
      ddd: [ 'alpha', 'beta', 'gunma', 'tochigi', 'saitama!', ]
      eee: { red: 0xff0000, green: 0x00ff0, blue: 0x0000ff, }
    }

keyは文字列型に固定されていますが、
valueはユーザーが定義する任意の型で構いません。

ハッシュオブジェクトをオブジェクト指向プログラミングの視点で見ると、
`aaa` `bbb`はJavaやC++などのクラスのメンバー変数に近いもの、
`ccc`はメンバー関数（メソッド）に近いものに見えませんか？

では、同じ視点で`ddd`と`eee`についても
クラスベースのオブジェクト指向言語に当て嵌めて考えてみましょう。
さて、これらは何に相当するのでしょう？

`ddd`はメンバー変数の配列？`eee`はメンバー変数の構造体？
その見当は間違いではありません。しかしもう少々考えてみましょう。

    {
      member_function1: function() { },
      member_variable1: 123,
      member_variable2: {
        mem_mem_variable: 456,
        mem_mem_function: function() { }
        
      },
    }

と、言う訳で、もしもクラスベースのプログラミング言語の経験があるのなら、
JavaScriptではオブジェクト指向プログラミングをする上で
ハッシュオブジェクトは全てクラスインスタンスの様なもので、
定義が評価されると同時にインスタンス化されているんだ、
くらいに捉えて措くと良いかもしれません。

ここまでではまだ
「ハッシュオブジェクトを使って、変数や関数を纏められるんだ」
くらいなものですが、
今回の講座ではよりオブジェクト指向らしく扱う方法について学習します。

## 8.2.this式

JavaScriptには`this`という言語組み込みで使える「式」があります。
`this`を使った簡単なサンプルを示すので、Node.jsで評価してみましょう: 

    > var o = { a:123, f:function(){ console.log( this.a ); } }
    undefined
    > o
    { a: 123, f: [Function] }
    > o.f()
    123
    undefined

さて、`this`式にはどんな効果があるのか見当は付きましたか？

`this`は**所属するハッシュオブジェクト**
を結果として返します。

よって`this`を使うとハッシュオブジェクトを１つの単位とした
オブジェクト指向プログラミングが簡単になります。

    var number_modoki = {
      current_value: 0,
      reset   : function() { this.current_value = 0;      },
      purapura: function() { return ++this.current_value; },
    };

この`number_modoki`オブジェクトは
`number_modoki.reset()`で保持する値を0に戻し、
`number_modoki.purapura()`で保持する値をインクリメントしつつ、
インクリメントした値を返します。

これ自体に特に意味はありませんが、
プログラムの構成要素を機能や動作単位ごとにオブジェクトへと小分けにする
「オブジェクト指向」プログラミングを実現する為の基本的な機能を確かめる事ができましたね。

さて、実はこの`number_modoki`は実は次の様に`this`を使わずに、
自分自身に付けられる予定の名前`number_modoki`を使って実装しても動作します: 

    var number_modoki = {
      current_value: 0,
      reset   : function() { number_modoki.current_value = 0;      },
      purapura: function() { return ++number_modoki.current_value; },
    };

しかし、これでは`number_modoki`の性質（メンバー変数やメンバー関数など）を持った
複数のオブジェクトを作った際に問題が生じてしまいます。
オブジェクトの名前をハードコード（＝決め打ちにしてソースコード中に埋め込む）してしまっているので、
実際の`Number`型のオブジェクトの様に自由に複数生成する事ができる様になったとしても、
常に名前が`number_modoki`のオブジェクトの`current_value`を操作しようとして不具合が生じてしまうでしょう。
それ故に`this`があるのです。

では、そもそもどうやって本物の`Number`型のオブジェクトの様に、
同じ性質を持ったオブジェクトを複数生成するのでしょう？
その方法の答えは次に説明する`new`です。

## 8.3.new演算子とdelete演算子

せっかくオブジェクト指向らしい事ができても、
共通の性質を持ったオブジェクトを複数実体化（＝インスタンス化）できなければ、
オブジェクト指向プログラミングを実現するのはとても大変で混乱したものとなるでしょう。

そこで、早速`new`演算子を覚えてしまいましょう。

### 8.3.1.new 演算子

次のコードを実行してみましょう: 

    > var a = new function(){ this.x = 123; };
    undefined

さて、`a`には何が束縛されるのでしょう？

    > a
    { x: 3 }

驚きましか？
と、言うより何が起こったのか不思議な状態かもしれませんが、混乱する必要はありません。

`new`演算子はオブジェクトを新たに生成する特別な演算子です。
では、`new`演算子に渡しているオブジェクトは一体何でしょうか？
どう見ても関数ですね。そして、その関数の中で`this.x = 123`などと
唐突に自分自身がハッシュオブジェクトであるかの様なコードが記述されています。
そうして出来上がったオブジェクトは`a`に束縛され、その中身を覗いて見ると
`new`に渡した関数の内部でどこからともなくある事になったオブジェクト`{ x: 3 }`が入っています。

実はこの`new`演算子に渡している関数は、
**新しく生成するオブジェクトのコンストラクター**なのです！

もし、C++かC#かJavaかPHPを知って居るならば先のJavaScriptコードは次の様なコードと同じ意図となります。
意図するところの`new`の役割は同じで、その引数`c()`はクラスcのコンストラクターです。

- C++: [Gist-1](https://gist.github.com/2374128)
- C#: [Gist-2](https://gist.github.com/2374323)
- Java: [Gist-3](https://gist.github.com/2374402)
- PHP: [Gist-4](https://gist.github.com/2374500)

念の為、先のJavaScriptの`new`を使う簡単なサンプルコードもGistに上げておきます。

- JavaScript: [Gist-5](https://gist.github.com/2374554)
    - コンストラクターを変数に束縛して書くと [Gist-6](https://gist.github.com/2374679)

と、言う訳で`new`演算子を使えば「同じ構造（と内容）」の
「存在としては別々のハッシュオブジェクト」を簡単に生成できます。

<div class="note">
Note: ちなみに、JavaScriptの`new`演算子の後の関数呼び出しは、
`new f(123, 'abc')`の様に必要に応じて引数があっても構いません。
また、引数無しの場合は`new f()`と書いても、括弧を省略して
`new f`と書いても同じ挙動となる様に[ECMA-262][ECMA-262]の
"§12.2.2 The new Operator"で定義されています。
</div>

### 8.3.2.delete 演算子

`delete`演算子は、端的に言ってしまうとシンボルを無かった事にします。

C++を知っている人は「`new`があれば`delete`もある」と思ったかもしれません。
PHPを知っている人は[`unset`](http://php.net/manual/ja/function.unset.php)に似た意図を持った機能です。
C#やJavaにはJavaScriptの`delete`と同じ意図の機能はありません。

<div class="">
Note: C#やJavaにある程度詳しい人はGCの強制実行ならできると思ったかもしれません。
それはここで紹介する`delete`よりも後の始末の話です。
また、C++の`delete`はシンボルへの参照を破棄する機能ではありませんから、
厳密に言えばJavaScriptの`delete`とは異なる意図を持った機能です。
JavaScriptにはデストラクターもありませんしね・ｘ・
</div>

凡そそんな様な意図のものですが、
JavaScriptの世界は全てがハッシュオブジェクトでできているので
有る意味でそれよりも柔軟な機能となっています。

早速サンプルを試してみましょう: 

- [Gist-7](https://gist.github.com/2375014)

    var x = {
      aaa: 123,
      bbb: 456,
      ccc: 789,
    };
    console.log(x);
    delete x.bbb;
    console.log(x);

この実行結果は次の通り: 

    { aaa: 123, bbb: 456, ccc: 789 }
    { aaa: 123, ccc: 789 }

`delete x`を試してみたくなりましたか？

    > .load delete_sample1.js
    ...
    > delete x
    false
    > x
    { aaa: 123, ccc: 789}

あらまあ消えませんでした。
よく注意を払ってこの挙動を眺めると、`delete x`が`false`と評価を返して居た事に気付いたでしょう。
実は`delete`演算子には存在を消し去る事の出来る相手と出来ない相手が居ます。

    > delete x.aaa
    true
    > x
    { ccc: 789 }

対象のシンボルを消し去る事を出来なかった場合には`false`を返します。
`delete`が消せない相手とはどんなものでしょう？

大域変数？その答えは違います。
`var`というキーワードで宣言した変数は`delete`では消せないのです。
また、例えば文字列型の`.length`の様なECMA-262の言語組み込みの機能も消せません。

<div class="note">
Note: JavaScriptの世界の最も外側にあるものは一体何でしょう？
答えを求めて次のコードを実行してみるのも良いかもしれません。 :)

- [Gist-8](https://gist.github.com/2375060)

ちなみにこれは答えではなくヒントです。 :)
</div>

<div class="note">
Note: なお厳密には「`var`したものは`delete`できない」とは[ECMA-262][ECMA-262]には書いてありません。
実際のところは何故`delete`できない相手が居るのかは[ECMA-262][ECMA-262]の"§8.12.7 [[Delete]] (P, throw)"
から紐解いて読んでみると良いでしょう。これが分かるとJavaScriptの仕組みがよく分かる様になりますよ。 :)
</div>

## 8.4.プロトタイプ

最後にJavaScript言語のオブジェクト指向プログラミング機能の要
「プロトタイプ」を紹介します。

## 8.4.1.プロトタイプとは何か？

次の動作を確認してみましょう: 

    > var f = function(){}
    undefined
    > f
    [Function]

ここまでは何もしない関数オブジェクトを１つ作り変数fに束縛しただけです。
では続けて: 

    > f.prototype
    {}

何か居ましたね。これがこの節で学ぶ**「プロトタイプ」**の片鱗です。
続けましょう: 

    > new f
    {}

空っぽの関数をコンストラクターにしたので、
`new`演算子で生成されたオブジェクトは空っぽです。
ここまでは`new`演算子の節で学習した内容でもなんとなくわかっていますね？

しかし、`new`の節では１つ疑問が残ったままになっているはずです。
この`{}`は一体どこからやってきたのでしょうか？
コンストラクターとした関数が評価される時点では既にありました。
何故なら`this.x = 123;`などが有効だったからです。

では、`{}`を作っているのは`new`演算子の言語組み込みの機能だったのでしょうか？
それは半分は正解です。しかし、残り半分は ... そう、
実は残り半分の答えが「プロトタイプ」だったのです！

この節で試したここまでの課程を良く観直して見ましょう。
どこかに`{}`が定義済みになってはいませんでしたか？

    > f.prototype
    {}

そうです、この`{}`が`new`演算子により新たに作られるオブジェクトの
**原型（＝プロトタイプ）**として使われていたのです！

本当にそうなのか試してみましょう: 

    > f.prototype = { aaa: 123, bbb: 456, ccc: 789 }
    { aaa: 123, bbb: 456, ccc: 789 }

コンストラクターとして使う関数オブジェクトの`.prototype`を書き換える事はできた様です。
では、この状態で改めて`new`を試してみましょう: 

    > var a = new f
    undefined
    > a.aaa
    123
    > a.bbb
    456
    > a.ccc
    789

おめでとう！予想通りコンストラクターに用いた関数オブジェクトの
`.prototype`に放り込んだオブジェクトが、
`new`で作成して`a`に束縛したハッシュオブジェクトのプロトタイプとして使われ、
`a`では特別定義した訳ではない`aaa`や`bbb`や`ccc`を参照する事ができました。

できましたが、念の為`a`に束縛されたオブジェクトを確認してみましょう:

    > a
    {}
    > a.aaa
    123

`a`の中身は`{ aaa: 123, bbb: 456, ccc: 789 }`だと思った事でしょう。
残念ながら`a`の中身は`{}`です。
でも、`a.aaa`は確かにコンストラクターのプロトタイプにしたハッシュオブジェクトの`aaa`を取り出せて居ます。
ミステリーが増えてしまいましたね・ｘ・

今のところの皆さんのJavaScriptのオブジェクト指向プログラミングへのミステリーは２つ。
１つは`.prototype`は何時誰が定義して初期状態でも`{}`が入っていたのか。
そしてもう１つは`new`で作ったオブジェクトは自身は`{}`のままなのに、
コンストラクターのプロトタイプに定義したプロパティ`aaa` `bbb` `ccc`を参照できているのは何故か。

最初のミステリーの答えは仕様書で
「JavaScriptの関数オブジェクトは暗黙にプロパティ`prototype`として`{}`を持つ」
と定義されているからです。実は仕様なので定義されているというだけの理由です。

もう１つのミステリーの答えは、実は先ほどの文章の中の
「コンストラクターのプロトタイプに定義したプロパティ`aaa` `bbb` `ccc`を参照でき」
と言う部分がそのまま答えになっています。
どういう事か、次のコードを続けてみましょう: 

    > f.prototype.aaa = 'tea'
    'tea'
    > a.aaa
    'tea'

そうです、確かに`a`に束縛されたハッシュオブジェクトそれ自身は`{}`ですが、
コンストラクターのプロトタイプへの参照を保持しているのです！
それゆえ、コンストラクターのプロトタイプのハッシュオブジェクトの値を書き換えると、
そのオブジェクトを参照していた`a`に束縛されたハッシュオブジェクトの`.aaa`も
`123`では無く`tea`を返したのです！

絵に描くとこう: 

![figure.8.4.-1](images/prototype.png)

`new`で作られたハッシュオブジェクトは、
その作成に使われたコンストラクター関数オブジェクトの
`prototype`が参照するオブジェクトへの暗黙の参照を持つのです。
それゆえ`a`は自身は持っていないが参照元のハッシュオブジェクトが持っている
`aaa` `bbb` `ccc`へ暗黙的にアクセスできるし、
その参照しているオブジェクトの値が変更されると、
`a`からその変更された`aaa`にアクセスしても変更後の値へとアクセスできたのでした！

これを「プロトタイプによる継承」と呼びます。
JavaScriptはプロトタイプベースのオブジェクト指向言語なのです。

<div class="note">
Note: 参考として、クラスベースのオブジェクト指向言語のクラスでは、
「オブジェクトの設計図」をクラスとして定義して置き、
その設計図から実際に使う実体（インスタンス）を生成する仕掛けです。
プロトタイプベースのオブジェクト指向では、クラスの様な純粋な設計図を用意するのではなく、
設計図としてではなく実際に既に存在するオブジェクトを原型にして新しいオブジェクトを生成します。
JavaScriptではこの実装手法として原型のオブジェクトへの透過的な暗黙の参照を持たせた訳です。
</div>

### 8.4.2.プロトタイプ継承とコンストラクターでのthisの使い分け

次のコードはどちらも同じ様にしてそれぞれ`x`、`y`の値を取り出せます。

①コンストラクターでプロトタイプから生成されるオブジェクトに`this`式を使う:

    > var a = new function(){ this.x = 123; }
    undefined
    > a.x
    123

②プロトタイプとなるハッシュオブジェクトを定義する:

    > var f = new function();
    undefined
    > f.prototype = { y:123 }
    { y: 123 }
    > var b = new f
    undefined
    > b.y
    123

これだけならばどちらでも良い、或いは簡潔に書ける①の方が②よりも良いと思っている人もいるかもしれまん。
しかし、その考え方は誤りです。
JavaScriptに於けるオブジェクト指向プログラミングでは、基本的には②を用います。
何故でしょう？

先ほどの例の`a.x`は`a`が`{}`を原型として作られた後に`this.x = 123`によって追加されたものです。
`a.x`はプロトタイプへの参照ではなく、`a`自身の中に`x`を持っているのです。

それに対し、`b.y`は`b`が`{ y: 123 }`を原型として作られた為に、`b`自身は`{}`であっても、
`b.y`は原型に`y`があるので透過的な暗黙の参照によってアクセスできたのです。

つまり、コンストラクターで`this.x`を追加する方法は派生した後のオブジェクトを変化させて対応、
プロトタイプを`{y:123}`とする方法は派生元のオブジェクトを変化させて対応するという違いがあります。

### 8.4.3.instanceof 演算子

さて、プロトタイプ継承がどういったものか分かったところで、
最後に１つだけまだ学習していなかった演算子`instanceof`について紹介しておきます。

    > var constractor = function(){}
    undefined
    > var base = { aaa: 123 }
    undefined
    > constractor.prototype = base
    { aaa: 123 }
    > var delivered = new constractor
    undefined
    > delivered instanceof constractor
    true

`delivered`が`constractor`から`new`で作られたオブジェクトかどうか確認したい際に、
`instanceof`演算子を用いて`delivered instanceof constractor`とするとBoolean型で教えてくれるという訳です。

<div class="note">
Note: `delivered instanceof base`では無い事に注意しましょう。
</div>

## 8.5.コメント

プログラムの規模が大きくなってくるとソースコード中にコメントを埋め込みたい要求があるかもしれません。

    var x = 123; // 行末までコメントに
    
    /*
      囲まれたブロックをコメントに
    */

必要に応じて`// ToDo: xxはyyしてから実装する`とか使ったり、
コードのデバッグの為に活用したりすると良いでしょう。

但し、やたらとなんでもかんでもコメントでごちゃごちゃと書いて措けば良いというものではありません。
ソースコードはそもそも人間が読み書きする為の言語であり、その部品１つ１つのトークンは言葉なのです。
出来る限りコメントなど無くても意図の分り易いソースコードを記述する能力はプログラマーとしての能力の高さの１つです。
保守性の高いソースコードを書ける力を身に着ける事は、
JavaScriptに限らず様々な言語を扱う上でプロジェクトの、そして自分自身への大きな手助けとなるでしょう。 :)

### 8.A.1.オブジェクト指向JavaScriptプログラムサンプル

今回の内容のまとめとして、
ニュートンの運動方程式の第1法則（＝等速直線運動）を
オイラー法によりシミュレーションする簡単なサンプルプログラムを用意しました。

- [Gist-9](https://gist.github.com/2383615)

このサンプルを参考に、自分（たち）が作ろうとしているJavaScriptプログラムの設計について、
どの様にプロトタイプやコンストラクターのthis式を用いれば良いか考えましょう。


[prev]: ../0007/
[next]: ../0009/

[gist]:   http://gist.github.com/
[ideone]: http://www.ideone.com/

[ECMA-262]: http://www.ecma-international.org/publications/standards/Ecma-262.htm

