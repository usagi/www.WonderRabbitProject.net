--
title:     5. JavaScriptの「本当の」基礎
parent:    JavaScript ⇠ Lectures
published: 2012-04-05 08:30
modified:  2012-04-06 14:00
--

<a target="_blank" href="https://github.com/usagi/www.WonderRabbitProject.net/commits/master/Lectures/JavaScript/0005/main.ja.markdown">
<ul class="datetime">
  <li class="published"><time pubdate datetime="$published$">$published$</time>
  <li class="modified"><time datetime="$modified$">$modified$<time/>
</ul>
</a>

<nav>

##### 概要

今回から（漸く？）JavaScriptの基礎的な型システムや制御文、
一般的な処理系の挙動、言語仕様などJavaScriptそのものについての講座となります。

今回はJavaScript言語を知識として学習する上では最も重要な要素となる
この言語における**型システム**について講義します。

なお、以降は毎回、講座の前半でJavaScriptに関する講義を行い、
講座の後半はJavaScriptのプロジェクトに実際に取り組む時間とします。

状況に応じて楽しく学ぶ時間としましょう・ｗ・ｂ

##### 内容

* [5.1.JavaScriptの型システム](#javascriptの型システム)
    * [5.1.1.JavaScriptの型](#javascriptの型)
    * [5.1.2.JavaScriptの型の一覧](#javascriptの方の一覧)
        * [5.1.2.1.Number型](#number型)
        * [5.1.2.2.String型](#string型)
        * [5.1.2.3.Boolean型](#boolean型)
        * [5.1.2.4.Object型](#object型)
            * [5.1.2.4.1.配列リテラル](#配列リテラル)
        * [5.1.2.5.Undefined型とNull型](#undefined型とnull型)
    * [5.1.3.JavaScriptの型変換](#javascriptの型変換)
        * [5.1.3.1.暗黙の型変換](#暗黙の型変換)
    * [5.1.4.JavaScriptの型の分類: 値型と参照型](#javascriptの方の分類値型と参照型)
        * [5.1.4.1.配列リテラル](#配列リテラル)
    * [5.1.5.リテラル](#リテラル)
* [5.A.付録](#a.付録)
    * [5.A.1.プロジェクトのスタートアップ](#a.1.プロジェクトのスタートアップ)

</nav>

## 5.1.JavaScriptの型システム

あるプログラミング言語について、それがどのような言語であるのか
学習し始める際は、その言語の型システムに注目してみると良いでしょう。

さて、皆さんはまだ様々なプログラミング言語や計算機の扱い慣れている訳ではありませんから、
あまり抽象的な事はおいおいの機会に話すとして、先ずは具体的にこれから扱うべき対象について解説していきます。
もし、余裕があれば他のプログラミング言語と比較しながら覚えても構いませんが、
混乱しない様に十分に気をつけて臨んで下さい。

ここから先を読む前に、いつでもすぐに試せる様にNode.jsのインタープリターを起動して措くと良いでしょう。

<div class="note">
Note: 今回教える内容の一次情報は"[ECMA-262 5th][ecma262]§8 Types"にあります。
余裕があれば是非、言語仕様原文にも目を通して見ると良いでしょう。
初めて言語仕様書を読むときには全ての事を出てくる順に理解して行くのは難しいと思います。
読む必要性を感じた節ごとに、徐々に読み込んで行くと良いでしょう。
</div>

### 5.1.1.JavaScriptの型

皆さんは変数を宣言する時にvarを使うことを既に知っています。次の例では変数`a`を宣言し、
値`123`を初期値として定義しています。

    > var a = 123;

ここで、突然ですが`a`の型は何でしょう？答えは`typeof a`とすると分かります。

    > typeof a
    'number'

より正確に言えば、これは「変数`a`の型」ではなくて、
変数`a`に入っている「中身の型」が`number`型です。
`typeof`という演算子は与えられたオブジェクトの型を
文字列で教えてくれるJavaScript言語組み込みのキーワードです。

<div class="note">
Note: ちなみに、「変数に値を入れる」と思っているであろうそれは、
専門用語的には「変数に値を束縛する」とか言います。
主体は変数ではなくて、値のオブジェクト
（それ自体は名前も何も無く純粋にデータと言える様な「モノ」です）
だと考えると、「なるほどそういう表現になるのか」とかちょっとしたアハ体験になるかもしれませんね。
</div>

JavaScriptではJavaScriptが実行する世界の中で`typeof`をする対象は「変数」である必要などありません。
皆さんがまだ`typeof`の結果をまだ知らない様々なオブジェクトの型を`typeof`で確かめてみましょう！

    > typeof "mojimoji"
    > typeof 'moji2222'
    > typeof 3.14159265358979
    > typeof function(){}
    > typeof true
    > typeof [ 1, 3, 5, 7, 9 ]
    > typeof { name: "Namae", age: 20 }

予想とは異なる結果が示されるものはありましたか？
JavaScriptがオブジェクトに対して取りうる型は、
一般にプログラミングとしては少ない方です。
例えば整数値`123`と浮動小数点値`1.23`はどちらも
任意精度の数値型`Number`型として同様に扱われています。

また、先の例の`[ 1, 3, 5, 7, 9]`は
JavaScriptで配列を定義する為の糖衣構文の様なものですが、
実はこの構文で出来るオブジェクトの中身は
`{ name:"Namae", age:20 }`の様なハッシュ（＝連想配列）と
まったく、本当にすっかり同じだったりします。

### 5.1.2.JavaScriptの型の一覧

JavaScriptには次の型しかありません。
値の例も同時に挙げるので、それがどんな型か考えながら見て下さい。

- Number … 任意精度の整数型
    - 12345
    - 1.41421356
- String … 文字列型
    - 'auau'
    - "eoeo"
- Boolean … 真偽値型
    - true
    - false
- Object … （ハッシュ）オブジェクト型
    - null
    - [   a,   b,   c ]
    - { 0:a, 1:b, 2:c }
- Function … 関数型
    - function(){}
- Undefined … 未定義型
    - undefined
- Null … ナル型
    - null

#### 5.1.2.1.Number型

Number型が「整数」とか「浮動小数点」だとかを区別せずに単に「任意精度」となっています。
プログラミング言語の数値の取り扱いには
「計算は速いがハードウェアに依存性が高く、計算機の具体的な仕組みを理解していないと正しく扱えない方法」
と
「計算は遅いがハードウェアに依存せず、計算機の具体的な仕組みは意識しなくても扱える方法」
があります。ここでは詳しく説明しませんが、JavaScriptの言語仕様の基であるECMA-262では後者のみを仕様に入れました。
よって、JavaScriptプログラミングの中ではそれが「整数」であるとか「浮動小数点」であるとかは、
強く意識する必要はありません。

<div class="note">

Note: 「任意精度演算」や数値計算の処理速度などに興味があれば、
先ずはWikipediaの記事で概要を掴んでみると良いでしょう。

- [ja.Wikipedia/任意精度演算](http://ja.wikipedia.org/wiki/%E4%BB%BB%E6%84%8F%E7%B2%BE%E5%BA%A6%E6%BC%94%E7%AE%97)

</div>

#### 5.1.2.2.String型

String型の例には`'auau'`と`"eoeo"`を挙げました。どちらもソースコード上での書き方の違いだけで、
JavaScriptの処理系が内部で扱う上では「文字列型」として同じ扱いになります。例えば、

    > 'abc' === "abc"

この結果は`true`となります。JavaScriptはその出生からもHTMLと共に扱われる事が多いプログラミング言語です。
例えば`<meta charset="utf-8">`という文字列をJavaScriptで扱いたいとしたらどうしたら良いでしょう？

    > "<meta charset="utf-8">"

これはエラーとなります。`"`に着目して考えればすぐに気が付きますね。この様な時には、

    > '<meta charset="utf-8">'

と、すると簡単です。プログラミング言語にありがちな
文字列内に`"`を埋め込むための厄介なエスケープ(`\"`とか)
をしなくても簡単に扱うことができます。

<div class="note">
Note: プログラミング言語としては一般に`"`での囲いは文字列、
`'`での囲いは単一の文字を扱う事が多いのですが、
JavaScriptには「単一の文字」を扱う方法は「一文字しか含んでいない文字列」で代替するより他にはありません。
Number型による任意精度演算のみが提供されている状況とも言語設計の方針に整合性が見られますね。
</div>

#### 5.1.2.3.Boolean型

Boolean型は「`true`と`false`の何れかのみ」を表す、
プログラミングではお馴染みの1bitきっちりの概念を取り扱う為の型です。

#### 5.1.2.4.Object型

さて、ここまでで皆さんは凡そJavaScriptの型システムについて、
その概要や型変換に当たる機能の使い方などを学習できています。
残るは（ハッシュ）オブジェクト型を理解するだけです！

ハッシュと言う言葉はプログラミングの初学者には聞きなれないかもしれませんが、
プログラミングの用語としてはとてもポピュラーなもので、
言葉で言ってしまうと「キーとヴァリューのペアーのコンテナー」と言うデータ構造
を持つモノの事です。

    > { key1 : 123, key2 : 456, key3 : 789 }

基本はこの様に定義します。［｛「キー」と「ヴァリュー」のペア｝のコンテナー］ですね！

実は、JavaScriptでは、NumberとStringとBooleanとUndefinedの他は、
全てのオブジェクトがこのハッシュ型だったりします。
（実は関数オブジェクトもその実体はハッシュで管理されています。
但し、それについては今はまだ考え込む必要はありません。）

JavaScriptの（ハッシュ）オブジェクト型で重要な事は、キーは常に文字列型、ヴァリューは任意の型
と言う点です。キーは文字列型なので、

    > { "abc":"def" }

この様なハッシュオブジェクトの定義を行なっても構いません。これは、

    > { "012":"def" }

こんな様なキーを扱いたい場合には覚えていないと痛い目に遭う事になるでしょう。

さて、定義だけできても中の値を取り出せないと面白くありません。
値を取り出すには次の様にします。便宜上、先ずはObject型を変数に定義します:

    > var h = { aaa: 123, bbb: 456, ccc:789, "256":"aiueo", "3.1415":"tamanegi" };

このハッシュオブジェクトから値を取り出してみましょう:

    > h["aaa"];
    > h.aaa;
    > h[256];
    > h[3.1415];

以上は全て成功します。基本は`h["aaa"]`で、この取り出し方はどんなキーに対しても使用できます。

糖衣構文として、「取り出したいペアーのキー文字列が数'字'でも記号でも無い通常の文字で始まっている場合」には
`h.aaa`の様にして取り出すことができます。これはC言語のStruct、C++言語のクラスインスタンスのメンバー、
C#言語の、Java言語の、まあ、そういった構文を知っていると近い表現に親近感が沸くかもしれませんね。

また、別の糖衣構文として、「取り出したいペアーのキー文字列が数値（Number型）に変換しても等価な場合」には
`h[256]`や`h[3.1545]`の様に恰もハッシュオブジェクトのキーがNumber型であったかの様に取り扱う事もできます。
これは次に紹介する配列リテラルとの互換性を向上するのにも一役買っています。

なお、注意としてキーに文字列として`"null"`や`"undefined"`や`"true"`や`"false"`を使うことも勿論できるのですが、
そういったややトリッキーな挙動を狙う場合には十分にその必要性がユーザーにあるのか考え、余程覚悟を決めた上でのみ
そうした用法を用いる様にしましょう。つまり:

    var oresama_object = { "null":null, "true": 1, "false": 0 };
    oresama_object.true;
    oresama_object.null;

とかそういうね・ｗ・； もしもこのソースコードのユーザーが自分自身だけならば、
例えその謎実装仕様を３ヶ月後には自分でも理解できなくなっていたとしても、
被害は社会的に小さいかもしれません…。しかし、共同開発者がこのソースコードのユーザーだったら？
できるだけプログラミング言語で特別な意味のあるキーワードを独自仕様で定義して使わない方が、
一般にその言語を取り扱う上での可読性、保守性を考慮する上で良い選択となるでしょう。

<div class="note">
Note: これは入門向けの講座ですから、先生はWARNINGは発します。
でも「やったらできること」にERRORは発しません。
特に学生さんの場合、どうせ冒険するのならば学生のうちにしておいた方が楽ですし、止めはしませんよ。
でも課題提出であまりにも読むのがダルいソースコードが飛んできたなら、
先生のお給料の範囲内では読めないと判断してリジェクトするかもしれません。
それもまあ冒険だと思おうのならば良い経験になるかもしれません。
往々にして冒険には多大な時間を浪費するものですが、その覚悟があるのなら。 :)
</div>

##### 5.1.2.4.1.配列リテラル

内部的に（ハッシュ）オブジェクト型と同等に解釈されるものとしてには、

    > [ "abc", "def", "ghi", 345, 234, 123 ]

こんな様な書き方もあります。
これは（ハッシュ）オブジェクト型でキーを省略した配列ものと考えると良いでしょう。
つまりその実体は次の様なハッシュ型と等価です。

    > { "0":"abc", "1":"def", "2":"ghi", "3":345, "4":234, "5":123 }

なお、「扱えますよ」という例として、
内部の型をわざと途中で別のものとしましたが、
基本的にはその用途を考えれば、同じ型を入れて使う事が多くはなるでしょう。

<div class="note">
Note: 厳密に言えば、言語仕様上は配列リテラルは「配列型; Array」として定義されてはいるのですが、
実際には（ハッシュ）オブジェクト型の糖衣構文でしか無いので本節では敢えてその意図を伝える為に、
「配列リテラル」と言って紹介しました。
</div>

配列を扱いたい場合にまで（ハッシュ）オブジェクト型を書くのは面倒ですから、
用途を分けて混乱しない様に使いましょう。

#### 5.1.2.5.Undefined型とNull型

Undefined型はundefinedという値のみを許容した「何かが未定義な事をお知らせする」為だけに存在する型です。
「〜のみを許容」については、Boolean型は何を許容するか、Number型は何を許容するか、その様な考え方ができると
それほど違和感なく理解できるでしょう。

また、Null型も唯一の値nullの為だけに用意された型ですが、
こちらは「（宣言済みの特定の変数などが）局所的に今は意味のある値は含んでいませんよ」
という意図を表すものです。

undefinedはプログラマーが意図して使う為のものではありませんが、
nullは意図してコードに組み込む事もあるでしょう。
但し、どちらについても扱う可能性は常に存在しますから、
必要に応じて`typeof`による型チェックを組み込んだりできるように理解しておくと良いでしょう。

### 5.1.3.JavaScriptの型変換

JavaScriptはオブジェクトの型を変換…する事は厳密には「できません」が、
ある型のオブジェクトを別の型のオブジェクトから生成する事はできます。

    > "4321" + "1234"

こんな「計算」を真面目に試みるプログラミングの初学者は居ないでしょう。
しかし、ユーザーがウェブのフォームから数値を２つ入力し、
その足し算した結果を使いたいプログラムがあったらどうでしょう？
注意深く無い初心者が居たとしたならばきっと思わぬバグを実装してしまい、
もしかしたらその実装部分のテストを怠って、症状が現れた頃にはとっくに
どこが悪くて不具合が発生したのか分かり難い事態になってしまっているかもしれません。

さて、スパゲッティソースコードの話はさておき、
次の様にするとString型のオブジェクトからNumber型のオブジェクトを生成（コンストラクト）できます。

    > Number("4321") + Number("1234")

これは、文字列の`"4321"`から数値の`4321`、`"1234"`から`1234`を生成して、
それからその新たに生成された数値同士を足し算しますから、
その答えは`5555`となります。

プログラマーは常に「型」を意識してプログラミングします。
なんとなく答えがあっているうちは型なんて考えもしない様では
将来大きなバグを埋め込んで大変な思いをする事になるでしょう。

JavaScriptはダッグタイピング可能な一見すると動的型付けの様にも見えますが、
余程JavaScritに慣れて、ダッグタイピングしたコードが実行時にどの様な型付けを
されてどの様な挙動を示すのか常に意識できないうちは、型に十二分に注意しましょう。

### 5.1.3.1.暗黙の型変換

    > 1234 + "4321"

この結果はどうなるでしょう？結果はNumberでしょうか、それともString？
恐らく凡そ半数の人には予想外の結果が得られたでしょう。

では次の結果は？

    > 1234 - "4321"

この結果はNumberでしょうか、それともStringでしょうか？
恐らく今回は全員が予想を裏切られてしまうでしょう。

JavaScriptではダッグタイピング可能ですから、
文脈に応じた型の解釈が働きます。
しかし、プログラマーは行き当りばったりでプログラムを作ってはなりません。
あくまでもダッグタイピングも糖衣構文の延長の様なもので、
決して詳細を考えずとも処理系がウマイことやってくれる人工知能ではありません。

プログラマーは自分の書くコードがどの様な挙動を示すものか、
少なくとも言語仕様や自分が使う処理系については把握してコードを書きます。

先の例では、演算子`+`と演算子`-`によって、
「暗黙の型変換」が行われるルールが違うのです。
これはバグでは無く、そうしておくことで
JavaScriptのプログラマーが（それを知った上で使う事は当然の事なので）、
わざわざNumberやStringへの変換を明記しなくても素早くプログラムを書ける為の高度な機能なのです。

慣れない、或いは覚えられないよ！という場合には、

    > String(1234) + "4321"

    > 1234 - Number("4321")

この様に素直にプログラムを記述すれば良いでしょう。
なお、この例のように複雑なダッグタイピングの為の規則は、
ソースコードの可読性低下を招く事は自明ですから、
ポリシーとしてそれが嫌だという場合にも明示的にコードを書く癖を付けても良いでしょう。

### 5.1.4.JavaScriptの分類: 値型と参照型

JavaScriptの世界Number、String、Booleanは「値型」の型です。Object型は「参照型」の型です。
先ずはこれまでに登場した（といってもこれで全てですが）JavaScriptの型をこの分類で整理して示します。

- 値型
    - Number
    - String
    - Boolean
    - Undegined
    - Null
- 参照型
    - Object
        - (Array)
        - (Function)

と、言う訳で、（ハッシュ）オブジェクト型のみを参照型として分けて考える必要がある場合があります。
例を１つ挙げるので、どんな時にこの分類を意識しなければ思わぬバグを埋め込んでしまう事になる可能性があるのか
考えてみましょう。

    var a = 123.456;
    var b = a;
    a = 654.321;
    console.log( a + b );
    var x = [123.456];
    var y = x;
    x.0 = 654

#### 5.1.5.リテラル

型システムの終わりに、「リテラル」という言葉についても触れておきましょう。
プログラムのソースコードに`1234`とか出てきたら、これを「数値リテラル」と呼びますし、
`"ヒャッハー！"`と出てきたらこれは「文字列リテラル」と呼びます。

プログラムのソースコードは人間にも、コンパイラーにも可読なテキストデータです。
何らかの値を定義して使おうと思えば、プログラマーはソースコードを文字列で書きます。
その時、「どういう規則で書いてあればそのトークンは何型である」と言う事を
リテラル（＝ソースコードの文字列上のお約束）と言います。

なお、蛇足次いでに、プログラミングにおいてソースコード上でトークンと言った場合には、
コンパイラーがソースコードを解釈するに当たって、
「それ以上分解できないプログラム言語読み取りの上での単語」
の事を言います。

ちなみに、Number型に解釈されるリテラルにはどんなものがあるでしょうか？
少し考えて列挙してみて下さい。１０進数だけとは限りませんよ＾＾

## 5.A.付録

### 5.A.1.プロジェクトのスタートアップ

さてさて、講座を実際に受講している学生の皆さんには、
JavaScriptの型システムの講義は最初の１コマと少々を、
続く２コマ目の途中からはJavaScriptを使った実際の案件へ自由に
取り組み始めてもらいました。
と、言ってもまだ自分の脳内や、一緒に取り組む仲間と相談したりして、
先ずは自分が何に取り組むのかを決めてリポジトリを作っただけの段階ですけれど！

そこで、今回の付録としては実際に案件に取り組む上での手順について簡単に紹介しておきたいと思います。
もちろん、この通りにやりなさいというものではありませんから、我流で進めても構いません。
以下は１つの参考として書くものです。

先ず、案件に対する最初のタスクは

- 作業の流れを考える

ことです。

恐らく案件を完成させるのに必要な個々の部品はある程度の経験が無いと想像すら付かないか、
部品の作り忘れに後から気が付いて沢山の付け焼刃に埋もれてワケワカメとなってしまう事でしょう。
そこで、先ずは完成図を考えて、そこから１つ１つ、
その完成図の為には何が必要で、その必要なものの為には何が必要で、
トップダウン式に必要な要素をどんどん枝分かれに掘り下げて考えて措くと良いでしょう。

と、言っても最終的な完成図をどう描いたら良いか、そこから悩んでしまうかもしれません。
文字通り、絵を描いてみるのが一番でしょう。完成品そのものではなく「完成の図」ですから、
つまり「完成品の絵的なイメージ＋その絵の中で動きのある部品などは押したり引いたりすると
どんな挙動を示すかのメモ」を描いてみましょう。

例えば、「この講座で実際に皆さんに取り組んで貰っている案件を
１つのゲームとして面白く演出するシステムを作る」案件があったとしましょう。
その完成図を描いてみるとこうなります。

<table>
<tr>
<td>
<a href="https://github.com/usagi/Girls/raw/master/design/visual-1.png">
<img src="https://github.com/usagi/Girls/raw/master/design/visual-1.png" style="float:left;width:65mm">
</a>
<td>
<a href="https://github.com/usagi/Girls/raw/master/design/visual-2.png">
<img src="https://github.com/usagi/Girls/raw/master/design/visual-2.png" style="float:left;width:65mm">
</a>
<td>
<a href="https://github.com/usagi/Girls/raw/master/design/visual-3.png">
<img src="https://github.com/usagi/Girls/raw/master/design/visual-3.png" style="float:left;width:65mm">
</a>
<tr style="text-align:right;">
<td>Visual-1
<td>Visual-2
<td>Visual-3
</table>

これはソフトウェアのデザイン（ソースコードの「設計」もデザインですね）
の一部であるソフトウェアのヴィジュアル（＝見た目）のデザイン資料で「ワイヤーフレーム」と言われるものです。

背景をコルクボードにしたかろうが、枠線をフリフリにしたかろうが、そういった装飾と見做せる要素は後回しにし、
とりあえずは概要を簡単に（但しできるだけ正確に）示す基本的な線だけで絵を描きます。
もしも、よほど絵に自信が無いとしても何事も経験ですから、
フリーハンドじゃなくても定規を使って描いてみても構いませんし、まあ、なんとか描いてみましょう＾＾；

ちなみに、先のワイヤーフレームの例は手書き風のテンプレートを使ってるだけで、
まったくもってデジタルに、それも実はブラウザーアプリで描いてたりします。（参考: [Cacoo](https://cacoo.com/)）

何でも構いませんが、せっかくデジタルツールを使うのであれば、
ワイヤーフレームを変更したい時に消しゴムツールで消して・・・とかせずに済む様なレイヤーの工夫や
ベクターに強いツールを使うと便利ですよ。
お絵描き系でなく、プレゼンテーション用のツールを使って作るのも簡単です。

さて、最終的な絵や挙動についてだいたい分かる資料ができたなら、
あとはそれに前後して作るものの仕様を固めて、必要な部品を掘り下げて、
そうして作りはじめましょう！

<div class="note">

Note: 現実社会の実際の案件では、
先ずは案件の依頼主と相談して何が必要とされているのかを明確にし（要求仕様の確定）、
それからソフトウェアのデザイン（プロダクトの仕様の確定）、
そして仕様に基づいて実装を進め、
仕様を満たすプロダクトが出来ているのかテストし、納品する、と言った流れがあります。
そして最終的な納品はもちろん、それぞれのパート毎、また厳密には細かいタスク毎に納期目標があり、
あらゆるタスクが納期目標に収まる様に開発を進めます。
あまりにずさんだったり、無茶な計画だったり、
要求仕様がコロコロ変わったりすると・・・かの有名なデスマーチ状態に陥ってしまいます。

今回は講座としては納期目標は設けませんから、皆さんがやりたい事をやれるだけ、やってみたら良いと思います。
とは言え、せっかく案件に取り組むのですから達成感も味わえた方が楽しいでしょう。
適度に目標を区切ったりしながら、うまく案件を熟して案件充になりましょう＾＾

</div>

実際のところ、今回は次の様な手順で進めてみれば良いでしょう。

1. 案件の要求仕様を整理
1. 完成の絵を描く
1. 実現する為に必要となる機能を列挙する
1. 実装を進める
    1. モックアップを作成する
    1. （必要なら）モックアップ用のダミーデータを作成する
    1. モックアップの中身を少しずつ切り分けて本当の機能を組み込んで動作するようにして行く
        1. 切り分けた機能部位の完成条件を確認する
        1. 切り分けた機能部位の完成条件を満たす実装を行う
            1. その実装の為に必要な部品が大きければ作業を分割して小さくする
1. 全体が計画した通りにきちんと動作するか、脆弱性は無かろうか、チェックする
1. ユーザーの為の使い方を文書に整理する
1. リリースしてたくさんの人に使ってもらう

リリースしたら沢山のひとが使ってくれるかは完成度や要求次第ですが、
せっかくですから、何か面白いもの、役立つもの、楽しくなるものを作れば、
きっと相応の反響は得られると思いますよ・ｗ・ｂ

なお、作っている途中で、要求仕様を変更したくなる事があるかもしれません。
そんな時には闇雲に「やっぱりこうだったことに仕様」ではなくて、
「この変更で影響がでる工程はどこで、無駄になる事、新たに増える作業はどれくらいあるかな？」
と考えてみて、それからその仕様変更を今すぐにすべきなのか、
或いは一旦は現在の仕様で開発を進めて、仕様変更はそれが出来た次の版で改めて取り組むのが良いのか、
或いはそもそも変更しない方が良いのか、きちんと状況を見通して、整理して対応する様にしましょう。

<div class="node">
Note: 先の「工程」、もしも考える余裕があれば「単体試験」、
「結合試験」はどこでどういった事をする事に当たるのか考えてみたり、
興味があれば「テスト駆動開発」などの実装工程の進め方を取り入れてみたりしても良いでしょう。

</div>

[prev]: ../0004/
[next]: ../0006/

[gist]:   http://gist.github.com/
[ideone]: http://www.ideone.com/

