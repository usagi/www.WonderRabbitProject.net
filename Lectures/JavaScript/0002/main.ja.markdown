--
title:     2. 増える！うさぎペアー問題 - JavaScript - Lectures
published: 2012-03-29 07:25
updated:   2012-03-29 07:25
--

<pre class="datetime">Published: $published$
Updated  : $updated$</pre></p>

<nav>

##### 内容

* [2.1.増える！うさぎペアー問題](#増えるうさぎペアー問題)、
* [2.2.どんな問題なのかアルゴリズムを考えてみよう](#どんな問題なのかアルゴリズムを考えてみよう)
* [2.3.「ループ」を使って問題を解くプログラムを作ろう！](#ループを使って問題を解くプログラムを作ろう)
* [2.4.gistとideone、ソースコードを共有する](#gistとideoneソースコードを共有する)
* [2.A.付録](#a.付録)
    * [2.A.1](#a.1.)

</nav>

## 2.1. 増える！うさぎペアー問題

今回は突然ですが問題を出すので、
[前回][prev]習得したJavaScriptの知識を使ってプログラムを書いて解いてみましょう！

> 1. ある平原に、うさぎのペアー（♂&♀）がやって来ました。
1. うさぎのペアーは最初の一月は子供を作りません。
1. うさぎのペアーは二月目から毎月１ペアー（♂&♀）の子供を産みます。
1. 産まれたうさぎのペアーも二月目から同じように子供を作ります。
1. このうさぎたちはこの平原から外には出て行きません。
1. このうさぎたちは死にません。もちろん病気にもならないし、怪我もしないしその他諸々の細かいことは気にしなくて良いものとします。 ∪・ｘ・∪
* ＜問題＞ さて、１年後にうさぎのペアーは全部で何組になっているでしょう？

はてさて、どうやってこの問題を解きましょう？
今のところ使える武器は「変数」と「関数」の２つです。

とは言え、いきなりプログラムを書くのではなく、少しこの問題の性質について考えてみる事にしましょう。

## 2.2.どんな問題なのかアルゴリズムを考えてみよう

問題文（解決すべき課題）から「アルゴリズム」（解決する為の方法）を考えて整理してみましょう。

<div class="note">
Note: 今回の問題ではうさぎという設定でしたが、
ハムスターでもフェレットでもオコジョでも、
なぜか増えるイケメン♂でも幼女でもわかめでもしめじも松茸でもリアルマネーでも構いません
自分の学習意欲の上がりそうな楽しいものに（こっそりと自分の中だけで）
課題の登場人物やら何やらをすっかり置き換えて考えたりするとより楽しく取り組めるかもしれませんよ。
</div>

ここでは簡単の為、せっかくのかわいらしい設定のうさぎのペアーですが、産まれてから一月未満のうさぎペアーは`+`、
次の月から子供を作れる産まれてから一月以上経ったのうさぎペアーは`*`になって貰いましょう。ちなみに単位は`1[pairs]`、`2[pairs]`…としましょうか。
それから、平原という設定も素晴らしく素敵なイメージを楽しむ事ができて良いのですが、`[ ]`と表す事にしましょう。
この単位は`1[field]`、`2[fields]`…と考えられますが、
今のところの問題文では最初から最後まで平原は１つしか考えていないので、あまり深く考えておく必要は無さそうです。

こうして問題の意味が変わらない様に注意しながら簡単に整理すると、
紙や頭の中でこの問題を考える上でスマートに状況を把握しやすくなりますね。
（もしかしたら人によりけりかもしれまんが^^）

…さて、この問題に登場する要素はこれで全部でしょうか？本当に？

残念ながら、１つ問題文から読み残しがあります。それは「時間」経過についてです。
この問題を１つの世界とした時、それを構成するのに必要な要素に「時間」は欠かせない存在です。
見えないし、概念的なものだと思って曖昧にせず、これについても忘れずに状況を整理して措きましょう。

この問題の時間の範囲は「最初の状態」（＝初期状態）から、「１年後の状態」です。
では単位は`1[year]`、`2[years]`…いいえ、考えなくてはならない○の数が変化する単は一月毎です。
よって`1[month]`、`2[month]`…です。問題文の最後は年単位ですから、
もし回答に時間の単位が必要になれば、その時は`12[month]=1[years]`を使えばよいでしょう。

何やら細かくアレコレと決めすぎですって？確かに。

でも、君はこれから、自分自身の脳内や、あるいは紙とペンとメモ書きでこの問題を考えるのではありません。
これからこの問題をJavaScriptにプログラミングしなくてはならないのです。
計算機はプログラマーの思惑や課題内容を察してはくれません（少なくとも執筆現在の一般的な常識として）。

この問題をプログラムを作って解くという事の為には、
この問題の世界をまるごとシミュレーションしなければならないのです。
よって、この世界必要になりそうな事はできるだけ元の問題文からしっかり抽出して定義できるように準備するように心掛けましょう。

<div class="note">
Note: ここで手を抜くと、まあ今回の様な比較的簡単な問題であれば大きなミスにも繋がらないし、
実際にエラーやバグを含めたプログラムを作ってしまったとしても誰も死にはしないでしょう（たぶんですが）。
しかし、皆さんには来週からこれに比べたらちょっと大きなプロジェクトの完成を目標にJavaScriptでのプログラミングに
取り組んで貰います^^ 最初に作るべきものに必要な情報は何か、初期状態の定義はどの様であるか、
終了条件はどうであるか、必要となるアルゴリズムはどんなものだろうか、また、
プログラムを柔軟に、或いは高速に動作させられる様に改良するにはどうしたら良いだろうか、
そして勿論うっかりミスによるバグが出ないように、出難い様に、出てもどこが問題でどう修正すれば良いか
検討を付けやすい様にしておくにはどうしたらよいか良く考えてみましょう。
</div>

さて、ごちゃごちゃと述べるのはこのくらいにして、この問題の「最初の状態」を定義してみましょう。

    [ + ]
    0 [month]
    1 [+pair]

では次の状態は？時間経過は`1[month]`毎に考える必要がありますから、
`1[month]`を足した状態にこの世界を進めてみましょう。

    [ * ]
    1 [month]
    1 [*pairs]

気が付きましたか？うさぎのペアーの単位を1[pairs]ではなく、1[+pairs]とか1[\*pairs]と書きました。
これらを分けて考えないと、翌月からカウントが大混乱してしまいます。
そう、実は+と\*はこの世界のシミュレーションでは互いに関係はあるけれども、
別の存在として定義しておいた方が良さそうだと言う事に気が付きましたね！

では、この調子で次の月について考えてみましょう。

    [ * + ]
    2 [month]
    1 [+pair] + 1 [*pairs] = 2 [pairs]

おめでとうございます！元気な赤ちゃんうさぎが生まれましたよ！きっとかわいいでしょうね！

    [ * * + ]
    3 [month]
    1 [+pair] + 2 [*pairs] = 3 [paris]

毎回祝っていると大変なのでここからは冷静に考えてみましょう。
３ヶ月目になると\*が2組になりましたから生産力が2倍に増えた事になります。
続いてもう1ヶ月思考を進めてみましょう。

    [ * * * + + ]
    4 [month]
    2 [+pair] + 3 [*pairs] = 5 [pairs]

さらにもう一月。

    [ * * * * * + + + ]
    5 [month]
    3 [+pair] + 5 [*pairs] = 8 [pairs]

<div class="note">
Note: うさぎが16羽。ほえぇー(・∀・)
</div>

さて、現実に戻ってこの問題について、
ここまでに行ったこの世界のシミュレーションから、
この世界における一般的な法則性を見出してみましょう。

…いや、読み進めてもいいけどちょっと自分でも考えてみて下さい・ｘ・；

    0 [month] 1 [pair ] = 0 [*pair ] + 1 [+pair ]
    1 [month] 1 [pair ] = 1 [*pair ] + 0 [+pair ]
    2 [month] 2 [pairs] = 1 [*pair ] + 1 [+pair ]
    3 [month] 3 [pairs] = 2 [*pairs] + 1 [+pair ]
    4 [month] 5 [pairs] = 3 [*pairs] + 2 [+pairs]
    5 [month] 8 [pairs] = 5 [*pairs] + 3 [+pairs]
    n [month] z [pairs] = y [*pairs] + x [+pairs]

どうですか？何か「法則性のある変化」に気付きましたか？

この世界が始まってから`n [month]`の時の`z [pairs]`と`y [*pairs]`を足し合わせると
次の月`n + 1 [month]`の時の`z [pairs]`になっていますね。

> * z<sub>n+1</sub> = z<sub>n</sub> + y<sub>n</sub>

`n [month]`の時の`y [*pairs]`と`x [+pairs]`を足し合わせると
次の月`n + 1 [month]`の時の`y [*pairs]`になっています。

> * y<sub>n+1</sub> = y<sub>n</sub> + x<sub>n</sub>

`n [month]`の時の`y [*pairs]`は
次の月`n + 1 [month]`の時の`x [+pairs]`になっています。

> * x<sub>n+1</sub> = y<sub>n</sub>

おめでとう！この3つの式を毎月繰り返せば、ある月の次の月の`x`、`y`、`z`を計算できるね！
でも、もっと面白い規則が`z`だけを見ても見つかるはずだよ？

…そう、実はこの`z [pairs]`は、`[ (0) 1 1 2 3 5 8 ... ]`という数列になっている。
この数列をよく見ると…？もう気付いたかな？

> * z<sub>n</sub> = z<sub>n-1</sub> + z<sub>n-2</sub>

実はこの`z`にだけ着目すると、
ある時の`z`はその前の`z`とさらにその前の`z`の和になっているのです！

この世界の最初の状態から少しずつ異なる条件（今回は時間）の状態を
考えて、並べて、整理する事で、この世界での一般的な法則を見出す事に成功しました！

<div class="note">
Note: ちなみに数学的には「特殊解」（＝個別具体的な条件に於ける答え）の数列から
「一般解」（＝個別具体的じゃない、
大抵の場合は具体的な「値」ではなくて「式」として世界の法則性を表して於いて、
必要に応じて条件をこの式に代入するなどして特殊解を求められる一般性の高い「解」）
を見出した、という表現になります。
</div>

おめでとう！！すっきりと数式だけでこの世界の初期状態の定義と、
さらに任意の状態を計算する為に必要なアルゴリズムを見出し、
そうして問題に対する答えを計算するシンプルな方法が解ったのです！

これで後はこの整理できた「情報」を計算機で自動的に計算させる為のカラクリ、
つまりプログラムを書けば良いですね！

<div class="note">
Note: 数学の世界でも「値」は具体的な数値です。では「式」や「解」とは何でしょう？
「変数」が入り込んだままの「式」は「解」と呼んで良いのでしょうか？実は良いんです！
個別具体的な状況に於ける解は特殊解と言って、ある条件に固定された場合の式の末路を表しています。
それに対し、今回考えてみた様な、
「ある状態」の「世界」ではなくて「世界」そのものの法則としての「解」を「一般解」と言って、
これも「解」なのです。ただ、考える次元が１つ高次元に上がっただけの事で、その次元においては
具体的な値に束縛されてまとまらない変数が１つ低次元の時よりも多い、それだけの事なのです。
…と、この講座は数学の講座ではありませんので、
数学に興味が沸いたなら数学ガールでも物理現象の数学的諸言論でも、
中学校や高校の数学の教科書でも、ちょっとゆっくり落ち着いて、読み直して見ると良いかもしれませんよ^^
</div>

<div class="note">
Note: 実は今回の問題は「フィボナッチ数」の問題としてとても有名なものです。
[ja.Wikipedia][ja.wikipedia/fibonacci]でも比較的詳しく述べられて居ますから、
興味のある方は読んでみる事をお勧めしますよ。
</div>

## 2.3.「ループ」を使って問題を解くプログラムを作ろう！

さて、先の思考実験の結果得られたこの世界の単純な法則を早速JavaScriptでプログラムしてみましょう！

    var n   = 1;
    var z'' = 0;
    var z'  = 1;
    var z   = z' + z'';

おおっと！でもこれではダメです。数学では既に`z`がある時に、
その`z`の次の状態だとかちょっと変化させた時の状態をよく`z'`とか
さらにその次は`z''`とか表現しますが、JavaScriptでは`'`はちょっと別の意味を持った
言語組み込みのキーワードになっている事もあり、変数の名前には使えません。
そこで、こういう時には`x_`とか`y_`とか、
`\_`（アンダースコア）を使って`'`相当の意図を表したりします。

    var z__ = 1;
    var z_  = z_ + z__;

とりあえずこの世界、つまり今では作るべきプログラムの、初期状態の定義はできましたね！
しかし、これでは継続して世界を表現する為に、必要な月までの`z`を用意して`z_`、`z__`、…と、
どんどん並べて計算しなくてはいけませんね。そんな馬鹿げたプログラムを書いてはいけません！

<div class="note">
Note: プログラムを作る際には必ず保守性も考慮しましょう。
考慮しないと誰かがデスマーチして五寸釘とか樹海とかいう物騒な事になるでしょう。
</div>

そんな訳で「式」は「関数」にして何度でも呼び出せるこのプログラムの部品にした方が良いでしょう。

    var z = function(){ return z_ + z__; }

…ちょっと書き方は長くなってしましたね・ｘ・；
でも、プログラムは人間が読む為のものでは…ないことも無いのですが、
プログラムを作る目的は人間が読む為ではなく、計算機が実行する為にです。
計算機がプログラムを実行する段階では、通常1文字ずつ読み込んで単語を判断して…などという挙動は、
…しない事も無いのですが、まあ、本当の実行段階ではしません。

プログラム言語は人間が読んで、意味が分かるように書ける為に存在します。
ごく局所的でその変数がどう使われているか明らかである場合には、
数学の変数の様に短く機械的な名前の方が読み易く、内容も理解しやすいかもしれませんが、
`n`、`x`、`y`、`z`などはその変数が何を表すものであるかを考えた本人にしか意図がわかりません。
こうした場合にはプログラムの部品の名前は`n`ではなくて`current_month`だとか、
`z`ではなくて`current_pairs`にしておくと良いでしょう。
プログラムをメンテナンスするのが例え自分一人だけの場合でも、3ヶ月後、1年後にそれを見て、
意図が分からない名前が付いていて、挙動を追いかけてそれが何を表すものだったのかを考えなおし、
それから漸く本来とりかかろうとしていた作業を始めるだなんて馬鹿げていますからね！
メンテナスするのが他人だったりしたら、それはもう本当に最悪な事です。

と、言うわけでちょっと意味の分り易いコードにしてみましょう。

    var current_month = 1;
    
    var before_number_of_pairs  = 0;
    var current_number_of_pairs = 1;
    
    var next_number_of_pairs = function(){
      return current_number_of_pairs + before_number_of_pairs; };
    
    var update_field_moneth = function(){
      var next = next_number_of_pairs();
      before_number_of_pairs  = current_number_of_pairs;
      current_number_of_pairs = next;
      current_month = current_month + 1;
    };
    
    var print_field_state = function(){
      console.log(
        "草原は今 " + current_month + " ヶ月目、" +
        "うさぎのペアーは " + current_number_of_pairs + " 組だよ！");
    };

もののついでに表示用の機能も関数にまとめてみました。
このプログラムのソースコードを読めば、
このプログラムがどういう意図で書かれた部品から構成されているのか
だいぶ分り易くなりましたね！

さて、問題を解く為に必要そうな値に関するはこれで完璧ですね！
…でもどうやって世界の時間を進めて動かしましょう？

みなさんは既に「変数」と「関数」は使えますが、特に、
一般的な「手続き型」の設計に慣れていると、
これらだけではこの問題を解くのが随分と億劫な方法しか思い付かないかもしれません。
例えば、先の必要な部品たちの定義に続けて、

    print_field_state(); update_field_moneth();
    print_field_state(); update_field_moneth();
    print_field_state(); update_field_moneth();
    print_field_state(); update_field_moneth();
    print_field_state(); update_field_moneth();
    print_field_state(); update_field_moneth();
    print_field_state(); update_field_moneth();
    print_field_state(); update_field_moneth();
    print_field_state(); update_field_moneth();
    print_field_state(); update_field_moneth();
    print_field_state(); update_field_moneth();

こんな計算コードを`current_month = 12`になるまで、つまり12回分ベタベタを並べる…。
もちろん、そんな保守性最悪なコードを作ってしまう必要はありません。
ではどうしたら世界が進む様を表現できるでしょうか？その答えの１つは「ループ」を使う事です。

    while ( current_month <= 12 ) {
      print_field_state();
      update_field_moneth();
    }

`while`は言語組み込みのループを実装する為の機能の１つだよ！
`while`に続く`( expression )`を評価して、`true`ならば`{ body }`を評価して、
それからまた`expression`の評価にループするし、`false`ならば`{ body }`は評価せずに、
そのループの先へと処理を進める最も単純なループ機構です。

<div class="note">
Note: 条件式は`true`または`false`に評価される式（変数１つでも式だよ！）を用いて、
その何れであるかに応じて何らかの条件分岐（プログラムが次に何を実行すべきか、
その道筋を分岐させる）を行うために用いられる事が多く、
`a < b`は`a`が`b`よりも小さい場合、`a >= b`は`a`が`b`以上の場合、
`a == b`は`a`が`b`と「等価」な場合に`true`となります。
これについはまた後で詳しく紹介します。
</div>

さて、…おめでとう！！

これで１年後にうさぎが何羽に増えているか、
JavaScriptのプログラムで答えを得る事に成功しましたよ！！

それはじゃあ後は、今回作ったプログラムを先生に提出してみましょう。

## 2.4.gistとideone、ソースコードを共有する

さて、プログラムの課題が解けたなら、電子メールにファイルを添付して送る？
或いはメール本文にベタ貼りして送信しちゃう？

まあ、時にはそういう答えもあるよ。
でも、今時そんな方法はあんまりイケてないんだ。じゃあどうするのかって？
今時ソースコードをシェアするのには[gist][gist]や
[ideone][ideone]を使うのが簡単でクールな方法だよ☆（ゝω・）vｷｬﾋﾟ

* [gist][gist]
* [ideone][ideone]

使い方はとっても簡単。とりあえずどっちでもいいからサービスにアクセスして、
自分のソースコードをペタッと貼り付けよう。

それから、gistなら`name this file...`となっているところにそのファイルに付けたい名前を
入力して`Create Private Gist`か`Create Public Gist`ボタンを押してみよう。
ちなみに、付けた名前の拡張子（JavaScriptファイルなら通常は".js"だね）部分によって、
そのファイルの種類を判定して色付け表示してくれるよ！

ideoneを使うのなら、`choose language`からプログラムの言語を選んで、
それから`submit`ボタンを押すんだ。JavaScriptは2種類の具体的な処理系まで選べるけど、
今回はとりあえずどっちでもいいよ。

さて、そうしてソースコードをサービスに記録したなら、
そのURLを指示された方法で先生に送ってみよう。
後で時間がとれた時にチェックしておくよ・ｘ・ｂ

## 2.A.付録

## 2.A.1

[prev]: ../0001/

[ja.wikipedia/fibonacci]: http://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%9C%E3%83%8A%E3%83%83%E3%83%81%E6%95%B0
[gist]:   http://gist.github.com/
[ideone]: http://www.ideone.com/

