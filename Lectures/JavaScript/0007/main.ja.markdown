--
title:     7. JavaScriptの演算子と式
parent:    JavaScript ⇠ Lectures
published: 2012-04-11 22:54
--

<a target="_blank" href="https://github.com/usagi/www.WonderRabbitProject.net/commits/master/Lectures/JavaScript/0007/main.ja.markdown">
<ul class="datetime">
  <li class="published"><time pubdate datetime="$published$">$published$</time>
  <li>change log is here
</ul>
</a>

<nav>

##### 概要

今回はJavaScriptの演算子と式について講義します。

##### 内容

* [7.1.プログラミング言語に於ける演算子と式](#プログラミング言語に於ける演算子と式)
    * [7.2.JavaScriptの演算子](#javascriptの演算子)
    * [7.2.1.単項演算子 加減算系 `++` `--`](#単項演算子-加減算系---)
    * [7.2.2.単項演算子 符号系 `+` `-`](#単項演算子-符号系--)
    * [7.2.3.単項演算子 ビット反転 `~`](#単項演算子-ビット反転)
    * [7.2.4.単項演算子 否定 `!`](#単項演算子-否定)
    * [7.2.5.二項演算子 乗除算系 `*` `/` `%`](#二項演算子-乗除算系)
    * [7.2.6.二項演算子 加減算系 `+` `-`](#二項演算子-加減算系--)
    * [7.2.7.二項演算子 ビットシフト系 `<<` `>>` `>>>`](#二項演算子-ビットシフト系)
    * [7.2.8.二項演算子 関係性系 `<` `>` `<=` `>=`](#二項演算子-関係性系)
    * [7.2.9.二項演算子 等価性系 `==` `!=` `===` `!==`](#二項演算子-等価性系)
    * [7.2.10.二項演算子 ビット論理操作系 `&` `^` `|`](#二項演算子-ビット論理操作系)
    * [7.2.11.二項演算子 論理系 `&&` `||`](#二項演算子-論理系)
    * [7.2.12.二項演算子 代入系 `=` `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `>>>=` `&=` `^=` `|=`](#二項演算子-代入系)
    * [7.2.13.三項演算子 条件 `? :`](#三項演算子-条件)
    * [7.2.14.特殊な演算子 `new` `delete` `instanceOf` `typeof` `void` `in` `,` `.`](#特殊な演算子-new-delete-instanceof-typeof-void-in)
    * [7.2.15.演算子の優先順位と結合性](#演算子の優先順位と結合性)
* [7.A.付録](#a.付録)
    * [7.A.1.ゲーム開発プロジェクト事例紹介: 某Aiming社 Load of Knights](#a.1.ゲーム開発プロジェクト事例紹介-某aiming社-load-of-knights)

</nav>

## 7.1.プログラミング言語に於ける演算子と式

JavaScriptに限らず、プログラミング言語には一般的に演算子と式という概念
（通常これらは仕様書できちんと定義されている）があります。

プログラミング言語における要素はこれまでにもちらりと解説しているものを含め、
次の様な階層構造となっていると考えると良いでしょう。

    - ソースファイル群
      - ソースファイル
        - オブジェクト（クラスであったり構造体であったりプロトタイプであったり）
          - 関数
            - 文
              - 【式】
                - トークン（【演算子】、言語組み込みのキーワード、シンボル、リテラルなど）

この後個別にも解説しますが、「演算子」とは`a * b + c`の`*`や`+`の事です。
そして「式」とは「演算子」やシンボル（自分で名前を付けた「変数」など）を１つ以上含んだ
処理系が演算対象とするある部分の事です。

以下に例として、これまでに皆さんが学習できている内容を使って書いてみた
[FizzBuzz](http://ja.wikipedia.org/wiki/Fizz_Buzz)
問題を解く為のJavaScriptのプログラムを挙げます。
式や演算子が使われているところはどこか、自分でも考えながら見ましょう。

- [Gist-1](https://gist.github.com/2356610/823cabfada52fad360a0b15ad4f0f3c91c42ad3e)

<pre><code>var fizz_buzz = {
  
  range : {
    begin : 1,
    end : 100,
  },
  
  test : function(target_value, test_value) {
    return target_value % test_value === 0;
  },
  
  test_sets : [
    { value: 3, word: 'Fizz!', },
    { value: 5, word: 'Buzz!', },
  ],
  
};

for(var n = fizz_buzz.range.begin; n <= fizz_buzz.range.end; n = n + 1) {
  
  var words = '';
  
  for(var key in fizz_buzz.test_sets) {
    
    var test = fizz_buzz.test_sets[key];
    
    if ( fizz_buzz.test(n, test.value) )
      words = words + test.word;
  }
  
  if ( words === '' )
    words = String(n);
  
  console.log('n:' + n + ' "' + words + '"');
  
}
</code></pre>

<div class="note">
Note: ハッシュオブジェクトの定義に余分な`,`がくっついている事に気付いた人もいるかもしれません。
わざとらしく付けて置きました＾＾；
JavaScriptではハッシュオブジェクトの定義を終わる直前に`,`があっても自動的に取り除いてソースコードを解釈します。
今回の例の様に複雑なハッシュオブジェクトを定義する際には要素毎の区切りの`,`を忘れてしまったり、
定義の順序をCOPY&PASTEで置き換えた際に可笑しな事になってしまったりしてバグを埋め込んでしまう可能性が
高くなりますから、この定義末尾の`,`のルールを活用して常にすべての要素の定義の末尾に`,`を付けてしまう事で
そうしたバグを回避する手助けとなるかもしれませんね。
</div>

## 7.2.JavaScriptの演算子

先ほどのFizzBuzzのコード例では`=`、`%`、`===`、`<=`、`+`などが演算子と気が付ければ合格でしょう。

<div class="note">
実は`,`や`in`も仕様ではしっかりと演算子として定義されて居たり、
[ECMA-262][ECMA-262]よりもマクロな視点で考えると`{ }`やら`[ ]`やら`:`やらも演算子だと考える事もできるのですが、
学習を始めたばかりのうちはそこまで考えなくてもまあ良いでしょう・ｘ・
</div>

14の節に分けてJavaScriptの演算子を全て紹介します。
基本的にはどの演算子も多くのプログラミング言語で共通の用法がなされるものですから、
プログラミング言語一般の知識として通用します。しっかりと覚えてしまいましょう！

<div class="note">
Note: [ECMA-262][ECMA-262]では"§11"に演算子と式の定義がまとめられています。
</div>

## 7.2.1.単項演算子 加減算系 `++` `--`

「単項演算子」とは「対象を１つだけ取る演算子」の事です。
最も基本的な演算子として`++`と`--`について例を挙げて紹介しましょう。

    for ( var n = 10; n > 0; --n )
      console.log(n);

このコードは以下のコードと等価です。

    for ( var n = 10; n > 0; n = n - 1 )
      console.log(n);

`--n`は`n = Number(n) - 1`と等価で、`--`は「デクリメント（１引く）」と言う効果を持った単項演算子です。
同様に`++n`は`n = Number(n) + 1`と等価で、`++`は「インクリメント（１足す）」と言う効果を持った単項演算子です。

そして、`++`と`--`は対象の前後どちらに記述する事も出来ます。しかし ... 
、次の式の評価結果はどうなるでしょう？

    var n = 0;
    console.log(n);
    console.log(++n);
    console.log(n++);
    console.log(n);

このコードを実行すると、順に`0` `1` `1` `2`と表示されます。
何かの誤りではありません、これは正常な動作です。

`++n`は「①`n`の値を`1`増加させて、②式の評価結果として増加させた`n`を渡す」、
`n++`は「①`n`の値を`1`増加させるけれど、②式の評価結果としては増加させる前の`n`を渡す」
という違いがあります。

プログラミング業界ではそれぞれ「前置き」、「後置き」と区別して用いられていますから、
挙動を見誤らないよう、しっかりとその違いを覚えましょう！

<div class="note">
Note: ちなみに、JavaScriptの`++`と`--`は「lvalue」に対してしか用いる事ができません
（[ECMA-262][ECMA-262]でそう定義されているのです）。
「lvalue」の説明はプログラミングの専門的な知識を経た上で無いと正しく理解するのが難しいかもしれませんので、
その説明は省略しますが、「名前を付けてある変数に対して直接しか使えない」と言う事だと覚えて置くと良いでしょう。
つまり`++0`や`1++`や`++ ++ n`や`++ n --`などはそもそも正しいJavaScriptのコードとして評価されません。
処理系はエラーを発して停止してしまいます。
</div>

## 7.2.2.単項演算子 符号系 `+` `-`

単項演算子の`+`と`-`は１つだけの引数を取り、符号を操作する為の演算子です。基本的にはね。 :)

    > +1
    1
    > -2
    -2
    > - -3
    3
    > + - + - + - + 1
    -1

単純な演算子ですが、その効果はしっかりと[ECMA-262][ECMA-262]で定義されています。
`+`は事実上何も効果がありません。`-`は対象の符号を反転させます。

<div class="note">
Note: 加減算をする為には引数が２つ必要ですから、それは二項演算子の`+`と`-`です。
引数が１つだけでは、その引数の符号を変えないか、変えるか、それしか`+`と`-`にはできません。
</div>

さて、これだけなら小学校の算数の知識だけで理解できるのですが、
JavaScriptの単項演算子の`+`と`-`にはもう少々プログラミング上の意味づけが行われています。

    > '1'
    '1'
    > +'2'
    2
    > -'3'
    -3

単項演算子の`+`と`-`は何れもString型の文字列から解釈してNumber型の数値に変換します。
`+'123'`は`Number('123')`、`-345`は`Number('-345')`と等価です。
この挙動は二項演算子の`+`と`-`では少々異なるので注意してその違いについて覚えて於きましょう。

## 7.2.3.単項演算子 ビット反転 `~`

ちなみに、JavaScriptでは`123456`など普通に整数を書いてあれば、
それは「10進数整数リテラル」としてNumber型に解釈されます。
加えて`0x789abc`など`0x`を付けて16進数と解釈されます。

    > 0xff
    255

しかし、2進数リテラルはありません。
せっかくなので2進数を扱うための仕組みを作ってみましょう！

- 要求仕様
    - 2進数を表す文字列型`'1000'`を与えると10進数の数値型`8`に変換
    - 10進数の数値型`8`を与えると2進数を表す文字列型`'1000'`に変換
    - 任意の2進数を表す文字列と数値を変換する仕組みを実装する

之までに学習した内容＋２で作った2進数を扱う為の仕組みとそのテストコード次に示します。
考えて作るのはまだ難しいと思う方はとりあえず写経して見ましょう。
時間があれば自分でアルゴリズムを考えてみるのも良いでしょう。

- ＋２のヒント
    - 文字列の長さは文字列オブジェクトに`.length`で取得できる
    - 文字列オブジェクト`'hoge'`は`['h','o','g','e']`と等価である様に振る舞う

<pre><code>var binary = {
  
  number_to_string: function(v) {
    var r = "";
    while ( v >= 2 ) {
      var m = v % 2;
      r = m + r;
      if (m === 1)
        v = (v - 1) / 2;
      else
        v = v / 2;
    }
    return v + r;
  },

  string_to_number: function(v) {
    var r = 0;
    var b = 1;
    var m = v.length - 1;
    for(var n = 0; n <= m; ++n) {
      r = r + v[m - n] * b;
      b = b * 2;
    }
    return r;
  },
  
};

var x = 4;

var c = binary.number_to_string(x);
console.log(c);

var s = binary.string_to_number(c);
console.log(s);
</code></pre>

- [Gist-2](https://gist.github.com/2357298/39310f5dfcaae4841fe0eff5e9ce513a52f65c3e)

さて、これで皆さんは2進数を簡単に扱える様になると同時に、
JavaScriptでプログラムを実装する能力が少々身に付いた事でしょう。
早速これを用いて、本題の単項演算子`~`の挙動を確かめてみましょう！

先のコードを"binary.js"として保存してあれば、
Node.jsインタープリターで簡単にテストに使うこともできます。
ソースファイルを書き換えてテストするよりもコンパクト＆スマートですね。

    > .load binary.js

これで"binary.js"のコードをNode.jsインタープリターが読み込んでくれます。
続いて、32桁で先頭が1で始まる2進数を次の様に適当に定義し、xに数値にして入れ、
これをそのまま文字列に、また`~`演算子を適用して文字列にして表示してみましょう。

    > var x = binary.string_to_number('11100111110010111001001110001011');
    > console.log( binary.number_to_string(  x ) );
    '11100111110010111001001110001011'
    > console.log( binary.number_to_string( ~x ) );
    '11000001101000110110001110100'

桁の先頭の方の余計な0は表示されないので表示は何桁かずれてしまいますが、
全てのビットが反転している事が分かりましたね！

ところで、なぜ「32桁で1で始まる2進数」で試したのか分かりますか？

- ヒント:
    1. 32桁の2進数＝32-bitの値
    1. 数値には符号がある

実はJavaScriptの単項演算子`~`は対象を32-bitの符号付き整数として扱います。
計算機の内部で32-Bitの符号付き整数はどの様に扱われているか考えてみると、
なぜここで簡単の為には「32桁で1で始まる2進数」で試すようしたのかが分かります。

- [ja.Wikipedia/符号付整数表現](http://ja.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7%E4%BB%98%E6%95%B0%E5%80%A4%E8%A1%A8%E7%8F%BE)

32桁に満たない、例えば'1010'（＝10）の様な値を`~`に渡すと、
2進数で表せば'00000000000000000000000000001010'という32-Bitの符号付きの整数が処理される事になります。
するとこの`~`の結果は2進数では'11111111111111111111111111110101'となります。

... なります、が、この値は10進数ではどんな値でしょう？

32桁目、つまり先頭の1-Bitは符号として解釈されます。`0`ならば+の値、`1`ならば-の値。
よってこれは-の値です。
残りの31桁は値ですから、2の31乗＝2147483648通りの整数＝\[0..2147483647]を扱えます。
符号と併せて[-2147483648..0..+2147483647]までの0を含む4294967296通りの整数を表せます。

と、言う訳で、2進数の'1010'をJavaScriptの数値にし、
これに`~`を適用した結果`11111111111111111111111111110101`(32桁)は、
32桁目は数ではなく符号として扱われ`-`の`1111111111111111111111111110101`(31桁)と言う事になるので、
`11111111111111111111111111110101`(32桁の符号無し整数)＝4294967285では無く、
-`1111111111111111111111111110101`(1桁の符号ビット＋31桁の整数)＝-2147483637と言う事になる。

JavaScriptの数値型は通常の数として扱う上では任意精度整数であるが、
ビット演算を施す必要がある際にはこの様な内部的な取り扱いも熟知している必要があり、
少々厄介です。扱う際には十二分に注意を払いましょう。

<div class="note">
Note: ちなみに、[ECMA-262][ECMA-262]では8進数整数リテラルは定義されていませんが、
多くのJavaScript処理系では`0123`の様に先頭に0を付けた数値を8進数整数リテラルと解釈します。
実装依存の機能なので8進数リテラルを使ったコードを書く際には、
必ずそのコードが運用される計画のある処理系の仕様を確認し、
ドキュメントにも使用と処理系への依存性を明示する様にしましょう。
</div>

<div class="note">
Note: 実はJavaScriptには[ECMA-262][ECMA-262]で仕様として定義された
「Number型の数値をX進数表現の文字列にする」機能があります。
之を使うと先の`binary.number_to_string`の中身は`return v.toString(2)`だけで実現できます。
この様な便利な機能はJavaScriptのプロトタイプやAPIを学習した後に紹介します・ｘ・
</div>

## 7.2.4.単項演算子 否定 `!`

`!`は真偽値を反転させる演算子です。

    > ! true
    false
    > !! true
    true
    > ! ! ! ! ! false
    true

`true`は`false`へ、`false`は`true`へ。

## 7.2.5.二項演算子 乗除算系 `*` `/` `%`

[ECMA-262][ECMA-262]の乗除算系の二項演算子は３つ定義されています。

- `*` : `a * b` この式は積を求めます
- `/` : `a / b` この式は商を求めます
- `%` : `a % b` この式は剰余を求めます。

<pre><code>> 1 * 2 * 3
6
> 1 / 2 / 3
0.16666666666666666
> 47 % 12
11
</code></pre>

ちなみに、JavaScriptを含めた大抵のプログラミング言語の処理系では、
事実上、一般的な数式で優先順位が同じ演算子は左側から順に処理されると覚えて措いても構いません。

    > 3 * 4 / 5
    2.4
    > 3 / 4 * 5
    3.75

これについては§7.2.15で解説します・ｘ・

## 7.2.6.二項演算子 加減算系 `+` `-`

二項演算子の`+`と`-`は足し算と引き算です。

    > 3 + 4 - 5
    2

また、文字列同士に`+`を適用すると文字列を結合します。

    > '台湾' + '烏龍茶'
    '台湾烏龍茶'

さて、要注意事項として、
二項演算子の`+`と`-`にはダックタイピング用の特殊な機能があります。

    > 45 + 'グラム'
    '45グラム'
    > String(45) + 'グラム'
    '45グラム'

`+`のどちらか一方が文字列型ならば、他方の数値型の値は文字列型に変換されます。

    > '1024' - 768
    256
    > Number('1024') - 768
    256

`-`のどちらか一方が数値型ならば、他方の文字列型の値は数値型に変換されます。

もしこの様な複雑なルールを使い熟せないと感じたならば、
異なる型同士を処理する可能性がある場合には必ず目的の型への明示的な型変換を書く様に心掛けましょう。
それによって少々ソースコードの嵩が増えたとしても、バグは減るでしょう。
バグが減るならばデバッグに悩む謎の時間も減り、設計と実装をてきぱきと熟せる様になるでしょう。

<div class="note">
Note: 文字列と数値の暗黙の変換については、
実は`-`演算子が特別な挙動と言う拠りは、`+`演算子が特別な挙動と考える事もできます。
`'3'-0`の他にも`'3'*1`や`'3'<<0`、なども文字列を数値に暗黙的に変換します。
これらに共通する事は「そもそも文字列を扱う演算子では無い」事です。
</div>

## 7.2.7.二項演算子 ビットシフト系 `<<` `>>` `>>>`

ビット演算が再び登場しました。§7.2.3で用意した2進数を扱う為の"binary.js"を使って動作を確かめて見ましょう。

    > binary.number_to_string(binary.string_to_number('10100101') >> 1)
    '1010010'
    > binary.number_to_string(binary.string_to_number('10100101') >> 2)
    '101001'
    > binary.number_to_string(binary.string_to_number('10100101') >> 3)
    '10100'
    > binary.number_to_string(binary.string_to_number('10100101') >> 4)
    '1010'
    > binary.number_to_string(binary.string_to_number('10100101') >> 5)
    '101'
    > binary.number_to_string(binary.string_to_number('10100101') >> 6)
    '10'
    > binary.number_to_string(binary.string_to_number('10100101') >> 7)
    '1'
    > binary.number_to_string(binary.string_to_number('10100101') >> 8)
    '0'

`>>`は右ビットシフト演算子です。
対象の値をNビット右へシフト（移行）させ、1桁目より右側へ追いやられた部分は消滅します。

    '-2147483648'
    > binary.number_to_string(binary.string_to_number('10100101') << 1)
    '101001010'
    > binary.number_to_string(binary.string_to_number('10100101') << 2)
    '1010010100'
    > binary.number_to_string(binary.string_to_number('10100101') << 3)
    '10100101000'
    > binary.number_to_string(binary.string_to_number('10100101') << 4)
    '101001010000'

`<<`は左ビットシフト演算子です。
対象の値をNビット左へシフトさせ、元々1桁目より右側にあったと仮定できる桁は0で埋めます。

さて、実は例によってJavaScriptのビットシフト演算を行う際には、
この演算子の適用における内部的な値の取り扱いについて注意が必要です。

    > binary.number_to_string(binary.string_to_number('10000000000000000000000000001000') >> 3)
    '-268435455'

binaryには負の値を32-bitの符号付き整数として扱う機能は付けていませんから、
負の値を上手く取り扱えずに想定外の出力を返しています。

これに対する最も簡単な対処が`>>>`演算子を用いる事です。

    > binary.number_to_string(binary.string_to_number('10000000000000000000000000001000') >>> 3)
    '10000000000000000000000000001'

`<<`と`>>`は内部的に値を32-bitの符号付きの整数として扱い、
ビットシフト演算に於いてもシフト処理の対象は下位の31bitsのみで、
上位1bitは符号としてシフト処理対象から外され保護されます。
`>>>`演算子は`>>`と同様に右シフトしますが、符号を特別扱いしない素直な右シフト演算を適用します。

<div class="note">
Note: JavaScriptの`<<`と`>>`はプログラミング一般に於いては「算術シフト」と呼ばれるビットシフト演算、
`>>>`は「論理シフト」と呼ばれるビットシフト演算です。
</div>

## 7.2.8.二項演算子 関係性系 `<` `>` `<=` `>=`

数学で言うところの不等号を用いた４つの演算子で２つの値の大小関係をBoolean型に評価します。

    > 321 > 543
    false
    > 321 < 543
    true

`<=`と`>=`は数学であればそれぞれ「≦」と「≧」です。

    > 10 < 10
    false
    > 10 <= 10
    true
    > 10 > 10
    false
    > 10 >= 10
    true

大小関係を比較するこれらの演算子群と次に示す等価性を比較する演算子群を併せて「比較演算子」と呼んだりもします。

## 7.2.9.二項演算子 等価性系 `==` `!=` `===` `!==`

２つの値の等価性をBoolean型に評価します。

    > 123 == 123
    true
    > 123 == 321
    false

`==`は素直ですね。「等しいか」を評価します。

    > 123 != 123
    false
    > 123 != 321
    true

`!=`は`==`と逆の結果となります。つまり「等しく無いか」を評価します。

さて、次の式と評価結果は本当でしょうか？試してみて下さい。

    > 123 == '123'
    true

一方はNumber型、他方はString型です。
しかし、比較出来た挙句、その結果はtrueと評価されました。
これはJavaScriptのダックタイピング機能の１つです。
本来であれば比較の仕様がありませんが、次の様に処理系は解釈してくれる訳です。

    > String(123) === '123'
    true

さて、今回は`==`では無くて`===`を用いている事に気が付きましたか？
`===`は型も含めた等価性を厳格に判断します。
`===`は「型も含めて等しいか」、`!==`は「型も含めて等しくないか」を評価する演算子なのです。

    > 123 !== '123'
    true
    > 123 !== 123
    false

さて、比較演算子の最後に要注意事項が１つあります。

    > [1,2,3] == [1,2,3]
    false
    > [1,2,3] === [1,2,3]
    false

これは非プログラマー、或いはプログラミング初心者の目には、「なぜ等価と判断されないの？」
と疑問を呈する事になるでしょう。
皆さんはプログラマーになるか、それに準じた学習を行なっている訳ですから
これが`false`と評価された結果とJavaScriptに於ける`==`や`===`の挙動について
しっかりと把握した上でこれを理解できなくてはなりません。
[§5.1.4](../0005/#javascriptの型の分類値型と参照型)を参考に考えて見ましょう。

ヒント: 

    > var x = [1,2,3]
    undefined
    > var y = x;
    undefined
    > x == y
    true
    > x === y
    true
    > var z = [1,2,3]
    undefined
    > x == z
    false
    > x === z
    false

気付けたでしょうか？
`x`は定義された`[1,2,3]`そのものに束縛されては居ません。
参照型のオブジェクトへの変数の束縛はその値そのものではなく、
その値はどこにあるのかという情報に束縛されます。

`x`（「最初に作った`[1,2,3]`はどこにあるか」）を複製した`y`は
`x`と同じ「最初に作った`[1,2,3]`はここだよ」という情報を保持しています。
よって、`x`と`y`は等しい訳です。

ところが、`z`と`x`は異なる`[1,2,3]`を示しています。
観測者にとっては同じ`[1,2,3]`と目には移るかもしれませんが、
これは通常の人間が蚊の１匹１匹をよく見比べても恐らく識別できない事と同様に、
観測者には識別する術が無いとしても、それらは確かに別々の存在なのです。

蚊の例えは本当に厳密に、よくよく観察すれば違いを見付けられるかもしれませんが、
綿菓子を作るお砂糖のザラメの１粒だったらどうでしょう？
或いは家電量販店の倉庫に到着したばかりの未開封のiPhoneや
１００円ショップで売られている乾電池でも同じ事です。
それらはこの世界の別々の座標に存在する異なるオブジェクトなのです。
最も、設計図は同じかもしれませんけれど。

<div class="note">
Note: アセンブラー、C、C++などのポインターもそういうものです。
「あるオブジェクトがその世界の座標（＝メモリーアドレス）のどこにあるのか」という値がポインターです。
</div>

## 7.2.10.二項演算子 ビット論理操作系 `&` `^` `|`

またまたビット演算です。binaryを使いましょう。

    > binary.number_to_string( binary.string_to_number('1010') & binary.string_to_number('1100') )
    1000

`&`はビット毎の論理積を評価します。両方とも`1`だった桁だけが`1`として残っていますね。

    > binary.number_to_string( binary.string_to_number('1010') & binary.string_to_number('1100') )
    1110

`|`はビット毎の論理和を評価します。何れか一方でも`1`だった桁は`1`になっていますね。

    > binary.number_to_string( binary.string_to_number('1010') ^ binary.string_to_number('1100') )
    110

`^`はビット毎の排他的論理和を評価します。互いに異なる状態だった桁だけが`1`になっていますね。

<div class="note">
長くて打つのが大変？
Node.jsのインタープリターは賢いので`bi`だけ書いてTABキーを押すと`binary`まで、
`binary.n`と書いてまたTABキーを押すと ... 。
</div>

ちなみに、ビット演算である事が分り易い様にbinaryを使っていますが、
もちろん次の様に本来は10進数同士を直接評価する事ができますし、
16進数リテラルを使っても構いません。

    > 1234 & 4567 ^ 7890
    7680
    > 0xFFFF ^ 0xFEFE
    257

## 7.2.11.二項演算子 論理系 `&&` `||`

`&&`と`||`はBoolean型の２つの値について、それぞれ論理積と論理和を求めます。

    > true && true
    true
    > true && false
    false
    > true || false
    false
    > false || false
    false

## 7.2.12.二項演算子 代入系 `=` `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `>>>=` `&=` `^=` `|=`

`=`は破壊的代入を行う為の演算子です。適用前に左辺に束縛されていた何かはすっかり忘れます。

    > var a = 123
    undefined
    > a
    123
    > a = 456
    456
    > a
    456

`*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `>>>=` `&=` `^=` `|=`は、
それぞれ全て=の付いて居ない演算子の挙動に従った計算と代入を同時に熟す
糖衣構文として定義される演算子だと考えて構いません。

    > var a = 123
    undefined
    > a += 456
    579
    > a
    579

    > var b = 'もじ'
    undefined
    > b += 'ぴったそ'
    'もじぴったそ'
    > b
    'もじぴったそ'

## 7.2.13.三項演算子 条件 `? :`

三項演算子ですから、３つのパラメーターを扱います。

    > true  ? 'abc' : 'def'
    'abc'
    > false ? 'abc' : 'def'
    'def'

この式全体で１つの演算子と３つの小さな式（というかトークンに等しい小ささ）を含んでいます。
この`a ? b : c`は次の関数と全く同じ効果を持っています。

    var hatena_colon = function(a, b, c) {
      if (a)
        return b;
      return c;
    };
    
    console.log( hatena_colon(true , 'abc', 'def) );
    console.log( hatena_colon(false, 'abc', 'def) );

これは何かの条件に応じて評価結果の値を変えたい場合にとても簡潔なソースコードを
記述する手助けとなります。

    for (var n = 1; n < 100; ++n) {
      var words = '';
      words += n % 3 == 0 ? 'Fizz!' : '';
      words += n % 5 == 0 ? 'Buzz!' : '';
      words = words.length > 0 ? words : n;
      console.log(words);
    }

しかし、これは簡潔でしょうか？
よく訓練された、その言語での演算子の結合順序と結合性を理解しているプログラマーならば
簡潔だと答えるかもしれません。
しかし、これは初心者にはやや難しいコードかもしれません。さらに: 

    for (var n = 1; n < 100; ++n)
      console.log(
        ( n % 3 == 0 ? 'Fizz!' : '' ) +
        ( n % 5 == 0 ? 'Buzz!' : n % 3 == 0 ? '' : n )
      );

これならどうでしょう？
実はこのコードもさっきのコードもどちらも同じ出力、
いわゆるFizzBuzz問題の答えを表示します。
綺麗に書いて於いたのでまだ読めると感じたかもしれません。

    for (var n = 1; n < 100; ++n)
      console.log((n%3==0?'Fizz!':'')
      +(n%5==0?'Buzz!':n%3==0?'':n));

はてさて、これは非プログラマーには
「よく解らないがすっきりスマートでコンパクトなコピペすれば良い何か」に思えるのかもしれませんが、
皆さんは恐らく違った感情を抱いたと思います。もしもこのコードに
「追加機能として7の倍数の時にはHoge!と言う様に仕様変更してくれ」という仕事がやってきたらどうしましょう？
もしかしたら、こんなソースを解読するよりも、
さっさと諦めてプログラムをまったくの零から再設計した方が要求仕様を満たすプロダクトを
早く、より低コストに完成できるかもしれませんね。

` ? : `演算子は２段階組み合わせただけでソースコードの可読性を
まるで暗号化でもしたような状態に陥れる事ができます。
使っても良いのですが、使うことによって「難読化」してしまうと感じたならば、
もっと意図を読み取りやすい記述で実装しましょう。
もしかしたら数時間後か、数週間後か、数カ月後か、数年後の自分自身を救うかもしれませんよ・ｘ・

## 7.2.14.特殊な演算子 `new` `delete` `instanceOf` `typeof` `void` `in` `,` `.`

`new`と`delete`と`instanceOf`と`.`はオブジェクト指向に関する機能を提供する為に用意された特別な演算子です。
最初に言って置きますが、JavaScriptにクラスはありません。
でも、JavaScriptはオブジェクト指向プログラミング言語の１つです。
これらについては次回§8で紹介しますのでお楽しみに。

`typeof`は既に[§5.1.1](../0005/#javascriptの型)で登場していましたね。
「対象の型の名前をString型で教えてくれる」演算子でした。

`void`は黒魔法です。あらゆる対象を`undefined`と評価します。
使う場面は想像できなくても構いません。

    > void 0
    undefined
    > void "フレア"
    undefined
    > void "デジョン"
    undefined

<div class="note">
Note: `undefined`はUndefined型の取りうる唯一の「値」だった事は覚えているかな？
`var q; if (q === void 0) console.log('MPが足りない');`ナンテネ・ｘ・
</div>

`in`は§6.2.4.`for-in`文で登場したあの`in`です。

> ＜「実は`in`は二項演算子で、`x in y`はyからxにキーを取り出す演算子だったんだ！」
> ＜ナ、ナンダッテー（AA略

いや、別にだからどうって事は無いので素直にあれは
`for-in`文という定形として覚えて措いて下さい・ｘ・

<div class="note">
Note: [ECMA-262][ECMA-262]の"§11.8.7"で定義されています。一応ネ・ｘ・
</div>

`,`は演算子です。

> ＜ナ、ナンダッテー（AA略

    > var a = 3, b = 4;
    undefined
    > a
    3
    > b
    4

`,`を使うと、こんな感じで複数の代入を単一の文で記述する事ができます。
`,`を使った場合は文の中で`,`の前を評価した後にその評価結果は聞かなかった事にして、
`,`の後の式を評価してその結果を`,`した結果とします。つまり:

    > a = 3, b = 4, c = 5;
    5
    > a
    3
    > b
    4

と言った具合で、`a = 3, b = 4, c = 5`という式の評価結果は
`,`の最後の右辺`c = 5`を評価した結果の`5`となります。
もちろん、`,`の左辺もその式の結果としては捨てられているだけで評価はされているので、
`a`は3、`b`は4が代入された状態になります。

    > for (var a = 0, b = 1; a * b < 100; ++a, b*=2) console.log(a, b);
    0 1
    1 2
    2 4
    3 8
    4 16
    undefined

とかも出来るんだけど、例によって可読性には気を付けてネ・ｘ・

<div class="note">
Note: [ECMA-262][ECMA-262]の"§11.14"で定義されています。
</div>

## 7.2.15.演算子の優先順位と結合性

演算子には「優先順位」と「結合性」があります。

演算子の優先順位とは「`+`より先に`*`を評価する」と言った式の中に複数の演算子があった際の
評価の優先順位の事です。

演算子の結合性とは「`a == b == c`に於いて`==`は左結合だから`(a == b) == c`と等価である」とか、
「`a?b:c?:d:e`に於いて`?:`は右結合だから`a?:b:(c?d:e)`と等価である」とか、
「演算子があった時に左右どちらの辺と演算子は結合するか」の性質の事です。

全ての演算子には「優先順位」と「結合性」があります。
凡そのルールとしては、単項演算子は優先順位が高く右結合性、
二項演算子は乗除算＞加減算＞ビットシフト＞関係性＞等価性＞ビット論理＞論理＞？：＞代入＞コンマと言った優先順位で、
代入と？：以外は左結合性です・ｘ・

と、言う訳なのですが ... 次の様に複数の演算子を組み合わせた時に、
評価される順序がどうなるか分かりますか？

    > 1 + 2 * 3
    7

この式の評価結果は幸いな事に初等数学を理解していれば判断に迷う事は無いでしょう。
では次の式の評価順序は分かりますか？

    > - 1 << 1 >> 1 === 2 * - 2 - 3 / 2 + 9 / 2
    true

もちろん、こんな無意味な式を作ってクイズをするのはナンセンスなので、
答えが何故`true`になるのか式を見て考えられるのはもう少しプログラミングに慣れてからで大丈夫ですし、
そもそもこんな難読な式をプログラムのソースコード中に書く必要性はまずありません。

もしも判断に迷う式を書いてしまう時には`( )`を有効に活用しましょう。
少々は可読性が向上するでしょう。

    > ( ( ( - 1 ) << 1 ) >> 1) === ( 2 * (- 2) ) - (3/2) + (9/2)
    true

大分読みやすくなりましたね。
しかしこの`( )`も使い方次第で可読性を却って悪くしてしまう事もあります。

    > (((-1)<<1)>>1) === (2*(-1))-(3/2)+(9/2)

括弧が連続していると詰めて書いてあるだけでもう嫌になりますね。

    function hoge(){
      var a = -1;
      var b = 2;
      var c = 3;
      
      var p = a << 1;
      var q = p >> 1;
      
      var x = b * a;
      var y = c / b;
      var z = c * y;
    
      return q === x - y + z;
    }

ものすごく無駄に複雑ですが、順に評価している事は単純なのでまあ・・・処理を追うことはできるし、
必要なら途中に`console.log(p)`など入れてデバッグする事も簡単になりましたね。

実際にこんな複雑な計算が必要ならば更に、
変数名を工夫してソースコードに記述されたプログラムの意図を汲み取れる様に工夫するなど
気を付けられる様になりましょう・ｘ・

## 7.A.付録](#a.付録)

## 7.A.1.ゲーム開発プロジェクト事例紹介: 某Aiming社 Load of Knights

- [いろいろ見せます♥Load of Knightsのクライアント開発事例紹介](http://www.slideshare.net/ppcchan/lord-of-knights)

某Aiming社の開発者がオンラインゲームの開発事例をSlideShareで共有してくれていたので紹介します。
特に前半のチーム開発に関しては小規模とは言え皆さんのチーム開発の参考になる事が詰まっていると思いますよ・ｗ・ｂ

[prev]: ../0006/
[next]: ../0008/

[gist]:   http://gist.github.com/
[ideone]: http://www.ideone.com/

[ECMA-262]: http://www.ecma-international.org/publications/standards/Ecma-262.htm

