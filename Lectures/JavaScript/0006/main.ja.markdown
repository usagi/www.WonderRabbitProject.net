--
title:     6. JavaScriptの「本当の」基礎・制御文
parent:    JavaScript ⇠ Lectures
published: 2012-04-10 00:15
--

<a target="_blank" href="https://github.com/usagi/www.WonderRabbitProject.net/commits/master/Lectures/JavaScript/0006/main.ja.markdown">
<ul class="datetime">
  <li class="published"><time pubdate datetime="$published$">$published$</time>
  <li>change log is here
</ul>
</a>

<nav>

##### 概要

前回の言語の基礎「型システム」に続き、
今回の言語の基礎**「制御文」**もしっかりと覚えて足固めに万全を期しましょう。

##### 内容

* [6.1.JavaScriptの制御文](#javascriptの制御文)
* [6.2.JavaScriptの制御文の一覧](#javascriptの制御文の一覧)
    * [6.2.1.do-while文](#do-while文)
    * [6.2.2.while文](#while文)
    * [6.2.3.for文](#for文)
    * [6.2.4.for-in文](#for-in文)
    * [6.2.5.continue文](#continue文)
    * [6.2.6.break文](#break文)
    * [6.2.7.return文](#return文)
    * [6.2.8.if文](#if文)
    * [6.2.9.switch文](#switch文)
* [6.A.付録](#a.付録)
* [6.A.1.制御文を使わない「高階関数」によるループ](#a.1.制御文を使わない高階関数によるループ)
* [6.A.2.JavaScriptの「文」のTIPS](#a.2.javascriptの文のtips)

</nav>

## 6.1.JavaScriptの制御文

実は皆さんには既に１つだけJavaScriptの制御文を軽く教えてあります。

    var x = 0;
    while ( x < 100 ) {
      console.log(x);
      x = x + 1;
    }

忘れてしまった人は[§2.3](../0002/#ループを使って問題を解くプログラムを作ろう)の
終盤の辺りをちらりと見てきても良いでしょう。

プログラミング言語に於いて**「制御文」**とは、
この`while`文の様に、
通常はソースコードの先頭から終端に向かって１つ１つ文（ステートメント）を評価して進む
プログラムの実行の流れを「制御」する為の「文」の事です。

一般にプログラムのソースコードは「制御文」を含めた様々な「文」の塊で出来ていて、
その１つ１つの「文」を評価（＝解釈して結果を求める）し進める事でプログラム全体が動作します。

<div class="note">
Note: JavaScriptの「文」は大きく２種類に分けられます。
１つは`var a = 1 + 1;`の様に`;`で区切られた単位（＝「単一のステートメント」）。
もう１つは、`{ a = 2 + 3; a = a / 2; }`の様に`{`と`}`で囲まれ、
内部に複数の文を含んだ単位（＝「ステートメントブロック」（というステートメント））です。
ちなみに、更に細かい`a = 1 + 1;`の中の`a`だとか
`=`だとかは「トークン」（＝解釈上の最小単位の単語みたいなもの）と呼びます。
</div>

特定の言語によらず、一般に用いられている多くのプログラミング言語では、
制御文を言語仕様で定義しています。
今回は現在一般に用いられているJavaScript処理系のベースとなっている
[ECMA-262][ECMA-262]で定められた制御文について１つ１つしっかりと学習しましょう。

### 6.2.JavaScriptの制御文の一覧

次に、JavaScriptで用いられる制御文について、
[ECMA-262][ECMA-262]の定義セクションを併せて一覧にします。

- 単純な繰り返しの為の文
    - while系
        - ① do { ... } while( ... ); // "§12.6.1 The do-while Statement"
        - ② while ( ... ) { ... } // "§12.6.2 The while Statement"
    - for系
        - ③ for( ... ; ... ; ... ){ ... } // "§12.6.3 The for Statement"
        - ④ for( ... in ... ){ ... } // "§12.6.4 The for-in Statement"

- 他の制御文の中でその制御の流れを変える為の文
    - ⑤ continue // "§12.7 The continue Statement"
    - ⑥ break // "§12.8 The break Statement"
    - ⑦ return // "§12.9 The return Statement"

- 条件分岐の為の文
    - ⑧ if // "§12.5 The if Statement"
    - ⑨ switch // "§12.11 The switch Statement"

<div class="note">
Note: 他に、`throw`文と`try`文が必修の制御文として存在するのですが、
これらの文（「例外処理」について）は特に重要であるのでまた別の回に改めて紹介します。
</div>

今回は以上の９つの制御文について存在を知り、
今後の発展への基礎固めとして使い方もしっかりと覚えてしまいましょう！

### 6.2.1.do-while文

とりあえず`do-while`文を用いた次のコードを実行してみましょう。

    var n = 0;
    do {
      console.log("n = " + n);
      n = n + 1;
    } while (n < 8);

この様な例をNode.jsのインタープリターを使って実行するには、
１行にまとめて次の様にします: 

    > var n = 0; do { console.log("n = " + n); n = n + 1; } while (n < 8);
    n = 0
    n = 1
    n = 2
    n = 3
    n = 4
    n = 5
    n = 6
    n = 7
    8

Node.jsのインタープリターは最後に`do`と`while`に囲まれた`{ ... }`の部分の評価結果も表示してくれますが、
今は差し当たり気にせずとも構いません。

と、言う訳で、do-whlie文では、
`do`（＝次のステートメントをやってみて）、
`while(条件式)`（＝`条件式`の評価結果がtrueの間）、
繰り返す制御（＝ループ）を記述できます。

このdo-while文によるループでは、
**条件の評価がループ対象のステートメントの評価の後に行われる**事がポイントです。
つまり、**必ず最低でも１回はループ対象となった文を評価する**事になります。

ちなみに、次に挙げるwhile文との違いは条件式の評価がループ対象のステートメントの
後か前かというだけの事です。混乱せずにしっかりと覚えて使いこなせる様にしましょう。

### 6.2.2.while文

先に述べた様に、while文はdo-while文と比べて条件式の評価タイミングが異なるだけです。

    var n = 0;
    while (n < 8) {
      console.log("n = " + n);
      n = n + 1;
    }

Node.jsインタープリターでは、

    var n = 0; while (n < 8) { console.log("n = " + n); n = n + 1; }

など１行で書くと良いでしょう。

while文では**ループ対象のステートメントの前**に条件式の評価を行います。
つまり、もしかしたら１回もループ対象のステートメントは評価されずに、
while文の評価が終わる可能性もあります。

whileとdo-whileを短いコードでよく比べてみましょう: 

    > while (false) console.log("ichigo-vanilla");
    undefined
    > do console.log("framboise"); while (false);
    framboise
    undefined

while文では条件式が`false`だとwhile内の文は１回も評価されません。
do-whileでは少なくとも１回はdo-while内の文が評価され、
それから条件式の判断を行なって繰り返すかの制御を決めています。

do-while文を使うか、或いは次に示すwhile文を使うかは、
その時々で都合の良い方を無理無く使い分けると良いでしょう。

<div class="note">
Note: `while (...) { ... }`の`{ ... }`の部分は文であれば構いません。
よって`while (...) ...;`というパターンも使えます。
しかし、もし君がプログラミングに不慣れか、
読み易く美しいソースコードを書く事にまだ自信が無ければ、
こうした制御文に渡す対象となる文については常に`{ ... }`を記述するのも１つの手です。
単一の文と文ブロックを自在に使い熟せない内は、
無理に格好を付けて単一の文を使い分け様としない方が良いかもしれません。
JavaScriptに限らず、プログラミングの初心者がバグを生み出す原因の代表的な例の１つに
本来ブロックであるべき部分をうっかり（？）`{`と`}`でブロック化して居ないという事が挙げられる為です。
</div>

### 6.2.3.for文

さて、whileの他に**for**というよく似た、しかしwhileよりは少々複雑な制御文があります。

少々複雑なだけあって、
代わりに先程while文で書いたコードと全く同じ意図のコードをすっかりスリムに記述する事ができます。

    for (var n = 0; n < 8; n = n + 1)
      console.log("n = " + n);

while文で５行も使って記述していたコードが、たったの２行に収まりました。
しかし、forの中身は少々複雑そうに見えるかもしれません。

少々複雑と言っても、先ほどのwhileでやっていた事をスリムに納めてあるだけです。
for文の記述の中身は次の様になっています。慌てずに落ち着いてしっかりと覚えてしまって下さい。

    for (①開始式; ②条件式; ④継続式)
      ③対象の文;

for文の評価は、
｛①開始式を評価、②条件式を評価、③対象の文を評価、④継続式を評価｝
と言う流れで行われます。条件式の評価はwhile文と同様の順序で行われるので、
場合によっては１回も③や④は評価される事無くfor文の評価が終わる事もあります。

    for (;false;)
      console.log("I want a cookie!!");

残念ながらこの叫びはソースコードを読んだ人にしか伝わりません。
条件式が`false`ですから、クッキーの叫びは評価されません。

さて、ここで大抵の人は別のポイントに「おや？」と気付いた筈です。
`for(;false;)`と言う記述には①開始式も④継続式も書かれて居ません。
それどころか実は次のfor文もJavaScript処理系は問題なく実行できます。

    for(;;)
      console.log("Give me a maple fudge, please!! X)");

この子は
[メープルファッジ](http://www.amazon.co.jp/%E3%82%A2%E3%83%AB%E3%83%86%E3%82%A3%E3%83%A1%E3%83%BC%E3%83%88%E3%83%95%E3%82%A1%E3%83%83%E3%82%B8-%E3%82%A2%E3%83%AB%E3%83%86%E3%82%A3%E3%83%A1%E3%83%BC%E3%83%88-%E3%83%A1%E3%82%A4%E3%83%97%E3%83%AB%E3%83%95%E3%82%A1%E3%83%83%E3%82%B8-150g/dp/B0038PMEJE)
をいくら貰っても延々と泣き続けるでしょう。
`for(;;)`は①開始式、②条件式、④継続式、これら３つ全てを省略した記述で、
実は無限ループとなり、

    whlie(true)
      console.log("まあ兎に角これもまた無限ループなのだよ。");

と同様の効果を齎します。つまり、
`for`の②条件式を省略した場合は`true`がデフォルト値になっていると言う訳です。

①開始式と④継続式はそれぞれ、
①＝「`for`の中身を評価する前に１回だけ」、
④＝「`for`の中身を評価し終えた直後に毎回」、評価される式です。
省略した場合にはそのタイミングでは何もしないだけとなります。

<div class="note">
ちなみにNode.jsのインタープリターで無限ループ（より正確にはビジーループ）を回すと
`CTRL+C`も`CTRL+D`も受け付けずに延々と処理を続けると思いますので実行する前に、
止め方についてきちんと知ってから試した方が良いかもしれません。
LinuxやUNIXでは落ち着いて別の端末を開いて`pkill node`、
あるいは`ps ac | grep node`として出てきた数値を`kill -KILL 31078`などとすると良いでしょう。
Windows NT6の人は`CTRL+ALT+DEL`を押してタスクマネージャーを起動し、
nodeを見つけてコンテキストメニュー（右クリックメニュー）からプロセスを終了させると良いでしょう。
</div>

<div class="note">
Note: よく考えて見ると、for文は、while文を一般化したものである事に気が付くかもしれません。
その通りです！つまり、for文の方が汎用性が高く、while文やdo-while文は用途がfor文よりは限定されます。
上手く使い分ける自信が無ければ、先ずは「ループはfor」と覚えてしまっても良いでしょう。
ちなみに、別の幾つかの言語にはwhileの条件式とループを継続するかの意味を逆さまにしただけの
untilという文があったりしますがJavaScriptにはありません。
whileの英語の意味を考えて知る事も良いでしょうし、
或いは「条件式はtrueの時に中身を処理する」と覚えてしまっても
JavaScriptを使う上ではまあ良いのかもしれませんね。
</div>

<div class="note">
Note: あんまりNoteを書き過ぎると野暮ったい気もしますが、この節の終わりに１つ。
プログラミング初心者が効率的に言語の仕様を覚える為には、その言語の世界の中での法則を見つけて、
その言語の世界で尤もらしいコードの書き方を感じ、見付け、自分でも真似て書ける様になる事です。
ところが、どんなプログラミング言語のfor文もこの点ではちょっとした落とし穴があります。
`for(;;)`の中のセミコロンは文の末尾のそれによく似ていますが、実は単なるセパレーター（分離する為の記号）です。
もしこれが文だとするとセミコロンは３つ無ければどうもしっくりこない事になりますね。
`for(;;)`文の中のセミコロンはただのセパレーターとしての記号、中に書くのは文ではなくて式を３つ。
だいたいどのプログラミング言語でも同様ですから、これは覚えてしまいましょう。 :)
</div>

### 6.2.4.for-in文

さて、do-whileとwhileの時とは違います。
先ほどのfor文とこの節のfor-in文は似て非なるモノと思っておいた方が良いかもしれません。

また、もしも君が他のプログラミング言語でforeach文を知っているとすれば、
それとも少々挙動違うものなので分かった気にならずに、
しっかりと本節でJavaScriptのfor-in文を身に着けられる様に注意した方が良いかもしれません。

と、脅かした上で早速for-in文のサンプルを書いて見ましょう！

    var ps = { ab: 12, cd: 34, ef: 56, gh: 78, ij: 90 };
    for (var k in ps)
      console.log(ps[k]);

この結果は、

    12
    34
    56
    78
    90

と出力されます。

JavaScriptのfor-in文は、
（ハッシュ）オブジェクト型の扱いに特化した繰り返しの為の制御文です。
寧ろ、繰り返しと言うよりは「集合」（＝ハッシュオブジェクト＝KeyとValueの組みが沢山入ってる）を
順に「列挙」（＝並べ上げる; イテレーション）する為の機能です。

JavaScriptの集合はハッシュオブジェクト型しかありませんから、
集合の要素１つ１つは「文字列型のkeyと何かしらのvalueの組み合わせ」しかありません。

それら要素が詰まった（もしかしたら０個しか詰まっていないかもしれないけれど）
ハッシュオブジェクトから値を取り出す為には、
「文字列型のkeyを順繰りに列挙してあげれば値もそのkeyを指定してオブジェクトから取り出せる」
と言う事になります。

そこで、JavaScriptはfor-in文を用意して、
ハッシュオブジェクトの中身を簡単に列挙できる様に設計されています。

次の例は先程の例をより意味が分り易い様に変更してみたものです。

    var ps = { ab: 12, cd: 34, ef: 56, gh: 78, ij: 90 };
    for (var k in ps) {
      console.log("key is: " + k);
      console.log("value of key is: " + ps[k]);
    }

ハッシュオブジェクトから、
for-in文はまだ列挙していないkeyがある限り、
片っ端から順にvar kに代入してループ内の文を評価します。

さて、ここで次のコードはどんな出力が得られるでしょう？

    for (var x in ["tea", "or", "coffee", "or", "else", "?"])
      console.log(x);

実行する前に少し考えて、
自分なりにどんな出力が得られるか考えてみて、それから実行してみて下さい。
連想配列リテラルではなく、配列リテラルを使っているところが悩ましいかもしれませんね・ｘ・

... 考えてみましたか？

... 本当にもういいですか？

... では答え合わせをしましょう！

    > for (var x in ["tea", "or", "coffee", "or", "else", "?"]) console.log(x);
    0
    1
    2
    3
    4
    5
    undefined

最後のundefinedはともかく、`0` `1` `2` `3` `4` `5`と順に出力されるのが答えです。
間違わずに考えられた人はおめでとう！！
もし、間違えてしまった人は（計算機的な意味で）素直に、シンプルに考えた事が正解になる事を覚えておこう。
つまり、前回学習した様に配列リテラルは単にハッシュオブジェクトの糖衣構文でしかないから、
JavaScript処理系はこのソースコードを`{'0':tea, '1':or ...`としか扱わないのです。すると答えは明白ですね！

<div class="note">
Note: とある言語には
[`foreach (pairs as $key => $value)`文](http://php.net/manual/ja/control-structures.foreach.php)
とかやると、foreach文だけでkeyもvalueも面倒を見てくれるものもあったりしますし、
またとある別の言語では
[`foreach(var value in values)`](http://msdn.microsoft.com/ja-jp/library/ttw7t8t6.aspx)
という列挙構文もありますし、
またとある別の言語では
[`for (auto value: values)`](http://ja.wikipedia.org/wiki/C%2B%2B11#.E7.AF.84.E5.9B.B2.E3.81.AB.E5.9F.BA.E3.81.A5.E3.81.8F_for_.E3.83.AB.E3.83.BC.E3.83.97)
という列挙構文もあります。
JavaScriptの列挙は「対象はハッシュオブジェクトである」事と「for-in文ではkeyが得られるだけ」という点で
他のプログラミング言語や環境とはやや異なる構文の挙動を示します。
もし複数のプログラミング言語のforeach構文を知る事になる際には混乱しない様にしっかりと挙動を区別して覚えましょう。
思わぬバグの原因となるかもしれませんよ！
</div>

### 6.2.5.continue文

さてさて、ここから３つは今までとは少々違った特徴を持った制御文です。
３つのうちの１つ目は`continue`文。早速、例を挙げるので試してみましょう。

    for(var n = 0; n < 3; n = n + 1) {
      console.log("check point A");
      continue;
      console.log("check point B");
    }

`check point A`と`check point B`はどの様に出力されたでしょうか？

この（無意味だが挙動を知るためには分り易い）例では、
`check point A`と`check point B`の間に`continue`文があります。

`continue`文は無条件に制御文の末尾（＝次の制御文の開始前）へと制御を飛ばします。
よって先の例では`check point A`が出力された後、
`continue`文により、その後ろにある`check point B`の出力は評価されずに次のループへと廻った為に
`check point A`だけが３回表示されたのでした。

`continue`はこの様にループの中で流れを断ち切って
「はい、もういいから次！」という効果を発動しますから、
乱用すると人間が制御を読み取り難いプログラムのソースコードになってしまいます。
`continue`を使うことですっきりと書けるコードがあるのならば良いのですが、
ループの処理が複雑になると感じた時には、
そのループで処理すべき対象を事前に絞る事で`continue`を使うよりも
ずっとすっきりとして高速に実行できるコードを実装できる事もあります。
使いどころを見極められる様になりましょう！

### 6.2.6.break文

`break`文も基本的にはループの中でその流れを制御する為に用います。
`continue`文とセットで覚えると良いでしょう。

    for(;;)
      break;

このプログラムを実行しても制御不能の無限ループには陥りません。
`break`（＝打ち切り）文は`continue`（＝継続）文とは逆の働きをします。
この例では`for(;;)`による無限ループに入る ... と、見せかけて、
forの対象ステートメント`break;`を評価すると「現在の制御文の進行を中断して抜ける」効果が発動し、
`for(;;)`から抜け出せるのでした。

これは非常に簡単ですが、ちょっと制御の流れは分かり難いかもしれませんね。
そこで、先の`continue`文と同様の例も示しましょう: 

    for (var n = 0; n < 3; n = n + 1) {
      console.log("check point A");
      break;
      console.log("check point B");
    }

先の§6.2.5.の`continue`を`break`に置き換えてみただけです。
この実行結果はどうなるでしょう？

... ちょっと考えてみてください。

... 予想できましたか？

答えは、「`check point A`が１回だけ表示される」でした。
`for`文の始まりに`var n = 0`が評価されるのは`continue`の例でも`break`の例でも同じです。
それから１回目の`check point A`に差し掛かるところも同じです。
次に、`break`文がありますから、現在のループを中断して、つまり`for`の外側に出てしまうと言う訳です。

<div class="note">
Note: `break`文はループを抜ける他にも、もう１つ重要な使われ方があります。
それはこの後、`switch`文の節で解説します。
</div>

### 6.2.7.return文

さて、処理の流れ、つまり文を１つ１つ解釈（評価）してプログラムが進む流れを変化させる３つ目の文は
`return`文です。

`continue`文、`break`文との違いは２つあります。
１つは、`return`文は①「ループの中の制御ではなく、関数の中の制御を行う為の文」という点。
もう１つは、②「パラメーターを１つ受け取る事ができる」という点。

①については次の例を実行してみると良いでしょう: 

    var f = function(){
      console.log("check point A");
      return;
      console.log("check point B");
    }
    f();

次の様に変数`f`を介さずに直接関数オブジェクトを評価する様に書いても構いません。

    (function(){
      console.log("check point A");
      return;
      console.log("check point B");
    })();

ループの中で`break`を使うのと似たような具合になりましたね？
つまり`check point A`の出力が評価された後、
`return`文は関数の実行をそこで中断し、関数の外へと制御を抜けたのです！

ところが`return`文の効果は`break`よりも少々高機能で、
②「パラメーターを１つ受け取る事ができる」という機能があります。
次の例を実行してみましょう！

先ずはパラメーターを持った`return`文を仕込んだ関数を定義しましょう。

    > var f = function(){ return 11223344; };
    undefined

次に、関数の入ったfに関数適用演算子`()`を適用して評価してみましょう。

    > f();
    11223344

もちろん、この`return 11223344`の結果は変数に束縛する事もできます。

    > var a = f();
    undefined
    > a
    11223344

`return`文の挙動について理解出来たでしょうか？
では次の式を評価すると`b`にはどんな値が束縛でしょう？

    > var b = (function(){ return; })();

これはちょっと難しいと言うか、言語仕様書を読まないと知り様が無いので
勿体振らずに答えを教えてしまう事にします。

答えは「`undefined`が`b`に束縛される」でした。
これは[ECMA-262][ECMA-262]の"§12.9 The return Statement"で言語の仕様として
「`return`文のパラメーターを省略した場合には`undefined`を返すよ」
と定義されている為に、JavaScriptの処理系は`undefined`を関数の結果として
関数の外側に渡し、よって`b`は`undefined`に束縛されたのでした。

<div class="note">
ちなみに、`undefined`は「未定義動作をしたよ！どうしよう！！うわぁーんエラーだー！！！」とか言う事ではなくて、
JavaScript処理系が正常な動作の結果として
「それは定義されていなかった事を示す値`undefined`を置いて措きますね( ´\_ゝ\`)」
と言う冷静な評価結果を示す単なる値ですから、
この値を見たからと言ってプログラムが暴走したり強制終了したりする事はありません。
しかし、通常は何かを評価して、
その結果意図して`undefined`を意味のある値として得ようとするプログラムを書く事はまずありませんから、
何かプログラマーがうっかり忘れていたり、あるいはミスがあって、それが原因で`undefined`な値が
プログラマーの意図としては非`undefined`であろうと思っていた部分に出現し、
そこから実行が中断されるようなエラーに繋がるという事はままあり得る事です。
</div>

<div class="note">
Note: 厳密には`return`文は関数ではなく言語組み込みの文ですから、
`return`文を関数に見立ててパラメーターを渡すと表現するのは少々違います。
とは言え、初学者にとってはその挙動という観点で見れば、
「関数の中で使える特別な関数みたいなもので、効果はパラメーター１つを取って、
自分の居る関数の外側にそのパラメーターを渡してあげるんだ」
の様に表面上の共通性を見出して学習の取っ掛かりにするのも良いでしょう。
但し、厳密にはちょっと違うのですよ・ｗ・
</div>

### 6.2.8.if文

JavaScriptの条件分岐は３つの方法があります。
そのうちの２つは`if`文と`switch`文です。

<div class="note">
Note: ちなみにもう１つはの条件分岐の方法は`?`演算子を使った式です・ｘ・
</div>

さっそく`if`文を使ってみましょう！

    for (var n = 1; n < 20; n = n + 1)
      if (n % 3 === 0)
        console.log(n);

`%`は講座の初めの頃に「剰余を求める演算子」として軽く触れましたが、
`===`はまだきちんと教えていませんでしたね。
後で「演算子」を講義する回も設けますが、
とりあえず今のところは
「`===`は左右２つのパラメーターが完全に一致していればtrue、そうでなければfalseを返す演算子」
と仮に解釈して読み進めて下さい・ｗ・

先のコードを実行すると、

1. for文の開始式`var n = 1`が評価される
1. for文の条件式`n < 16`が評価される
    - `true`だったのなら
    1. if文の中の式`n % 3 === 0`が評価される
    1. if文が中の式の評価結果を元に処理を分岐させる
        - `true`だったのなら、`console.log(n);`文が評価される
    1. for文の継続式`n = n + 1`が評価される
    - for文の条件式の評価へ進む（視覚的には戻る、処理としては進んでいる）

とまあ、こんな流れで処理が進みます。
この結果は、
`1`〜`19`の整数が順に、
`n % 3`で`1` `2` `0` `1` `2` `0` ... となり、
` === 0`で`false` `false` `true` `false` `false` `true` ... が得られ、
`if`文により`true`だった時のみ`console.log(n)`によりnが出力される。
つまり、このプログラムは`0`〜`15`までの`3`の倍数を出力する事になります。

この様に、if文を使う事で「ある条件式がtrueの時のみ続く文を評価する」事が出来ます。

さらにこの`if`文には`else`節をくっつけて、もう少し複雑な条件分岐を実現する事も出来ます。
`else`節を用いた例を挙げましょう。

    for (var n = 1; n < 20; n = n + 1)
      if (n % 3 === 0)
        console.log(n + " は３の倍数なのでした！");
      else
        console.log(n + " とか違いますしおすし…");

この実行結果は次の様になります。

    1 とか違いますしおすし…
    2 とか違いますしおすし…
    3 は３の倍数なのでした！
    4 とか違いますしおすし…
    5 とか違いますしおすし…
    6 は３の倍数なのでした！
    7 とか違いますしおすし…
    8 とか違いますしおすし…
    9 は３の倍数なのでした！
    10 とか違いますしおすし…
    11 とか違いますしおすし…
    12 は３の倍数なのでした！
    13 とか違いますしおすし…
    14 とか違いますしおすし…
    15 は３の倍数なのでした！
    16 とか違いますしおすし…
    17 とか違いますしおすし…
    18 は３の倍数なのでした！
    19 とか違いますしおすし…

この様に、`if`文に`else`節も併せて用いる事で「そうでない場合は」という条件への分岐を含んだ
少々複雑な条件分岐を簡単に記述する事ができます。

なお、`if`文と`else`節は他段階に組み合わせて用いる事もできます。

    for (var n = 1; n < 20; n = n + 1)
      if (n % 3 === 0)
        console.log(n + " は３の倍数なのでした！");
      else if (n % 5 === 0)
        console.log(n + " は５の倍数にござる・ｗ・");
      else
        console.log(n + " とかどっちでも無いですしおすし…");

実はこのプログラムには意図しないバグが含まれています。
少し考えてみましょう。
このプログラムはある範囲の数が３の倍数であるか、
また５の倍数であるかを教えてくれる事を意図して作られたものです。
出力もゆっくりと確認してみましょう、きっとバグに気が付けると思いますよ・ｗ・ｂ

    1 とか違いますしおすし…
    2 とか違いますしおすし…
    3 は３の倍数なのでした！
    4 とか違いますしおすし…
    5 は５の倍数にござる・ｗ・
    6 は３の倍数なのでした！
    7 とか違いますしおすし…
    8 とか違いますしおすし…
    9 は３の倍数なのでした！
    10 は５の倍数にござる・ｗ・
    11 とか違いますしおすし…
    12 は３の倍数なのでした！
    13 とか違いますしおすし…
    14 とか違いますしおすし…
    15 は３の倍数なのでした！
    16 とか違いますしおすし…
    17 とか違いますしおすし…
    18 は３の倍数なのでした！
    19 とか違いますしおすし…

どこにバグがあるかの答えは、
３と５の最小公倍数（つまりどちらの倍数でもある）の１５の時に初めて現れます。

気が付きましたか？
１５の時に３の倍数であると判定すると、
５の倍数であるかは判断していないのです・ｘ・

この問題は初心者がゲームを作る時にもよく発祥しているのを目にします。
キーボードの十字キーでキャラクターを操作できるシューティングゲームを作った時、
`if`と`else if`と`else`で次の様なコードを書いてしまうと、
２つのバグが含まれてしまいます。
どんなバグがあるのか考えてみましょう！

    if ( カーソルキーの上が押されていたなら )
      キャラクターを上へ移動する;
    else if ( カーソルキーの下が押されていたなら )
      キャラクターを下へ移動する;
    else if ( カーソルキーの左が押されていたなら )
      キャラクターを左へ移動する;
    else
      キャラクターを右へ移動する;

気が付きましたか？
１つ目のバグ（もしそういう仕様でなければ）は「キャラクターが斜めに移動できない事」、
２つ目のバグは「カーソルキーをどれか１つでも押していないと、キャラクターが右へ勝手に移動してしまう事」です。

さらに、ネストと言って`if`文を多段に組み合わせる事も、またこの後で紹介する`switch`文や今までに登場している
`for`や`while`、そして`continue`や`break`、場合によっては`return`文も組み合わせる事ができてしまいます。

    var f = function() {
      if (...) {
        for (...; ...; ...) {
          if (...) {
            if (...) {
              continue;
            } else {
              break;
            }
          } else if (...) {
            if (...) {
              continue;
            } else {
              return ...;
            }
          } else {
            return ...;
          }
        }
      }
      do {
        ...
        if (...)
          return ...;
        else if (...)
          continue;
        ...;
        if (...)
          ;
      } while (...);
    }

うん、実はかなりテケトーに書いた。はっきりいって意味はない・ｘ・；

JavaScriptは処理速度のチューニングを行おうと思うと、
ソースコードの可読性を維持する事が難しい状況もままあります。
しかし、ソースコードは人間が読み書きできる為に存在しますから、
上記の様な変態的に何をやろうとしているのか制御だけで意図がまるで読み取れない、
解読したくもなくなるようなソースコードは作らない様に気をつけると良いでしょう。

コツとしては、初めは「え、そんなに細かく？」と思う様な単位で、
できるだけ小さな数行単位のソースコードで関数に分けて実装する癖を付けると良いでしょう。

プログラムを書く際は、基本的にはソースコードの意図が分り易い、
保守性の良いソースコードを書ける様に心掛けましょう。

### 6.2.9.switch文

話が横道に逸れかけましたが、今回講義する[ECMA-262][ECMA-262]の「制御文」の最後は
`switch`文です。

多くの場合に`switch`文は`if`文で代用出来、
`if`文を使った方が意図せぬバグを防げる可能性が高い事から、
`switch`文の使用には慎重な意見が根強くあります。
しかし、正しく理解し、眠い時やお腹の空いている時に`switch`文を書かないように注意すれば、
これはこれで便利な側面も無い事も無いのです...。

と、言う訳で`switch`文の例を挙げますから、
先ずは`switch`文について正しくその挙動を理解し、
使いどころを見極められる様になりましょう・ｗ・

    var ps = ["foo","bar","hoge","fuga","another"];
    for(var k in ps) {
      var v = ps[k];
      console.log("current value is: " + v);
      switch(v) {
        case "foo":
          console.log("foo!");
        case "bar":
          console.log("bar!");
          break;
        case "hoge":
          console.log("hoge!");
        case "fuga":
          console.log("fuga!");
        default:
          console.log("default!");
      }
    }

少し複雑ですが、少々複雑な`if`文の組み合わせが基本だと思えばそれほど難しくはありません。

1. 先ず、`switch(式①)`で条件分岐の判定対象の式を指示します。
1. `case 式②:`で条件分岐するかを式①と比較して決定します。
    - もしも`① === ②`であれば、その`case`の内部を実行します。
    - `break;`文が出現しない限り`case`を滝のように流れ落ちながら処理します。
    - `case`の代わりに`default`を用いると、あらゆる①に対しヒットします。
    - `case`は連続で書いても構いません。

…言葉にすると複雑デスネ・ｗ・；
ちなみに「滝を流れ落ちる様に」の部分は「フォールスルー」と表現されたりもします。
さておき、とりあえず動作結果を見て見ましょう。

    current value is: foo
    foo!
    bar!
    current value is: bar
    bar!
    current value is: hoge
    hoge!
    fuga!
    default!
    current value is: fuga
    fuga!
    default!
    current value is: another
    default!

先ず、`switch("foo")`に対しては`case "foo":`がヒットし、
それ以降`break;`で流れを止められるまで途中に別の`case "foo":`があろうが処理が続いています。
次に、`switch("bar")`に対しては`case "bar":`がヒットし、
同様に`break;`が現れるまで処理されます。
`switch("hoge")`と`switch("fuga")`についても同様で、
`break;`が出現しないので`swtich`文の終わりまで全て処理が流れ落ちています。
`switch("another")`の場合も`default:`にはヒットしそこから先のコードが評価されています。

さて ... 、`switch`文について凡そ理解できたでしょうか？
`if`文でも似たことはできそうです。と、言うか出来ます。

    var ps = ["foo","bar","hoge","fuga","another"];
    for(var k in ps) {
      var v = ps[k];
      console.log("current value is: " + v);
      var f_foo     = function(){ console.log("foo!"); };
      var f_bar     = function(){ console.log("bar!"); };
      var f_hoge    = function(){ console.log("hoge!"); };
      var f_fuga    = function(){ console.log("fuga!"); };
      var f_default = function(){ console.log("default!"); };
      if (v === "foo") {
        f_foo();
        f_bar();
      } else if (v === "bar") {
        f_bar();
      } else if (v === "hoge") {
        f_hoge(); f_fuga(); f_default();
      } else if () {
        f_fuga(); f_default();
      } else {
        f_default();
      }
    }

或いは、より`switch`文と似たような判定と処理の流れとしたければ、

    var ps = ["foo","bar","hoge","fuga","another"];
    for(var k in ps) {
      var v = ps[k];
      console.log("current value is: " + v);
      var f_foo     = function(){ console.log("foo!"); };
      var f_bar     = function(){ console.log("bar!"); };
      var f_hoge    = function(){ console.log("hoge!"); };
      var f_fuga    = function(){ console.log("fuga!"); };
      var f_default = function(){ console.log("default!"); };
      if (v === "foo")
        f_foo();
      if (v === "foo" || v === "bar")
        f_bar();
      else{
        if (v === "hoge")
          f_hoge();
        if (v === "hoge" || v === "fuga")
          f_fuga();
        f_default();
      }
    }

これでも得られる出力結果は同じです。
では、`switch`文を使うべき理由は何でしょうか？

１つ目に、大量の分岐を処理する場合に
`switch`文は`if`文よりも高速に分岐判定を熟せる可能性がある点を挙げられます。
これは`if`文を大量に並べるよりも、`switch`文を使った方が１つの対象に対する
連続した比較処理の効率が良い可能性が高い為です。

２つ目に、`switch`文の「フォールスルー」を用いる事で
`if`文よりも簡潔にコードを書く事ができ、保守性も良好である場合です。
先ほどの例は挙動の確認の他には意味の無い例でしたが、`if`で書くよりも
`switch`で書いたバージョンの方がまだ幾分かは読み易い気はしますね。

しかし、特に理由が無ければプログラミングに余程慣れるまでは
`switch`文を積極的に使おうとしなくても良いでしょう。
慣れないうちは無理にイケてる`switch`文を書こうとすると、
バグを大量に埋め込んでしまって自分でも途方に暮れてしまうかもしれません。
しつこい様ですが、`switch`文は使いどころを見極めて使いましょう・ｘ・

## 6.A.付録

## 6.A.1.制御文を使わない「高階関数」によるループ

制御文を使わずにループを記述するにはどうしたら良いでしょうか？
関数を上手く使う事でこの課題に応える事ができるでしょう。

    var s = 0
    for (n = 0; n < 10; n = n + 1)
      s = s + n;
    console.log(s);

この`for`ループと同様の出力を制御文を使わずに関数だけで実現するには次の様にします: 

    var s = (function(n) {
      return (n === 10) ? n : n + arguments.callee(n + 1);
    })(0);
    console.log(s);

おっと、`?`演算子はまだ教えて居ませんでした！
`?`演算子を使うと制御文を本当に使わずに実現できてしまいますが、
これは皆さんが既に学習している`if`文に置き換えると次の様になります。

    var s = (function(n) {
      if (n === 10)
        return n;
      return n + arguments.callee(n + 1);
    })(0);
    console.log(s);

おっと…もう１つまだ講座で紹介していない機能`arguments.callee`が含まれてしまっていました。
これも使わないようにする事ができます。

      var s = 0;
      var f = function(n){
        if (n === 10)
          return n;
        return n + arguments.callee(n + 1);
      };
      s = f(0);
      console.log(s);

これで既に皆さんが知っている機能だけで、
`for`や`while`などのループの為の制御文を使わずにループを実現できました・ｗ・ｂ

ちなみに`arguments.callee`は「只今評価中のこの関数オブジェクトそのもの」を取り出す呪文、
`?`演算子は、`a ? b : c`と記述すると、

    (function(a, b, c) {
      if (a)
        return b;
      return c;
    })(a, b, c)

を評価してくれる演算子だと思って措いて構いません。
特に`arguments.callee`についてはその招待を知る為には
JavaScriptの実装の真の姿に接近する必要がありますので、
今はまだそういう呪文があるんだと思って措くのが良いでしょう・ｗ・；

## 6.A.2.JavaScriptの「文」のTIPS

次のプログラムは実は実行可能です: 

- hoge.js

    console.log("ほげほげ")
    console.log("ふがふが")
    console.log("ぽよぽよ")

？？？何を言いたいのか分かりませんか？？？

- fuga.js

    var x = 5 + 3 + 1
    var y = 6 + 4 + 2
    console.log(x + y)

なーーんか気付いた様な気がしますか？？？

答え、
「実はJavaScriptでは文の末尾を示すセミコロンは省略できる」
（[ECMA-262][ECMA-262]"§7.9 Automatic Semicolon Insertion"を参照のこと）

JavaScriptでは文の末尾にセミコロンを付けなくても、
利便性のためセミコロンを処理系が自動的に補って実行してくれるという仕様があります。
元からセミコロンが無い想定の言語ではなくて、ある想定だけど付けなくても勝手に推量してそれっぽいところに
セミコロンを加えてソースコードを解釈してくれるので、意図しない挙動となる事があります。

    console.log( (function(){
      return
      3 + 4
    })() );

これを実行すると`undefined`が表示されるでしょう。
`7`を期待しましたか？だとしたらセミコロンを省略せずにプログラミングした方が良いでしょう。

    console.log( (function(){
      return
      3 + 4;
    })() );

`return`文はじめ、JavaScriptの文は`;`による文の終端を言語仕様で必要としています。
それらを探せない時には`;`の終端をどこか適当と思しき場所へ勝手に付けて解釈してしまいます。
プログラマーは意図しない動作を避ける意味で、この`;`自動付与という一見便利そうな仕様を封印して
JavaScriptのプログラムを真面目に全てプログラマーが意図した文末に`;`をしっかりと付けて書くのが
一般的です。これは却って複雑な動作（＝JavaScriptの推論のルール）をプログラマーが覚えた上で
その推論の結果を推論してコードを書かなければ意図したプログラムを作れないという本末転倒の自体が
より多くのエラーを含む複雑怪奇で難解なプログラムを生み出してしまう可能性が高い事を
多くのプログラマーは理解している為です。また、一般にJavaScriptのプロダクトのデプロイ時に
行われるコード圧縮により、その挙動がさらに予測困難となる可能性もあります。
基本的には`;`はプログラマーが意図したコードを書いている事を容易に確信出来るよう、
きちんと付けながら実装する様にした方が良いでしょう。

[prev]: ../0004/
[next]: ../0006/

[gist]:   http://gist.github.com/
[ideone]: http://www.ideone.com/

[ECMA-262]: http://www.ecma-international.org/publications/standards/Ecma-262.htm

